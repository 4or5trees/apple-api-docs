<Type Name="NSTimer" FullName="MonoTouch.Foundation.NSTimer">
  <TypeSignature Language="C#" Value="public class NSTimer : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NSTimer extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("NSTimer", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The timer can trigger actions at certain time intervals.</summary>
    <remarks><para>You use the <tt>NSTimer</tt> class to create timer objects or, more simply, timers. A timer waits until a certain time interval has elapsed and then fires, sending a specified message to a target object. For example, you could create an <tt>NSTimer</tt> object that sends a message to a window, telling it to update itself after a certain time interval.</para>
    <para>Timers work in conjunction with run loops. To use a timer effectively, you should be aware of how run loops operate—see <tt>NSRunLoop</tt>. Note in particular that run loops retain their timers, so you can release a timer after you have added it to a run loop.</para>
    <para>A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed. Because of the various input sources a typical run loop manages, the effective resolution of the time interval for a timer is limited to on the order of 50-100 milliseconds. If a timer’s firing time occurs during a long callout or while the run loop is in a mode that is not monitoring the timer, the timer does not fire until the next time the run loop checks the timer. Therefore, the actual time at which the timer fires potentially can be a significant period of time after the scheduled firing time.</para>
    <para>NSTimer is “toll-free bridged” with its Core Foundation counterpart, <tt>CFRunLoopTimerRef</tt>. See “Toll-Free Bridging” for more information on toll-free bridging.</para>
    <para>Repeating Versus Non-Repeating Timers</para>
    <para>You specify whether a timer is repeating or non-repeating at creation time. A non-repeating timer fires once and then invalidates itself automatically, thereby preventing the timer from firing again. By contrast, a repeating timer fires and then reschedules itself on the same run loop.</para>
    <para>A repeating timer always schedules itself based on the scheduled firing time, as opposed to the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5 second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so far that it passes one or more of the scheduled firing times, the timer is fired only once for that time period; the timer is then rescheduled, after firing, for the next scheduled firing time in the future.</para>
    <para>Scheduling Timers in Run Loops</para>
    <para>A timer object can be registered in only one run loop at a time, although it can be added to multiple run loop modes within that run loop. There are three ways to create a timer:</para>
    <list type="bullet">
      <item><term>Use the <tt>scheduledTimerWithTimeInterval:invocation:repeats:</tt> or <tt>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</tt> class method to create the timer and schedule it on the current run loop in the default mode.</term></item>
      <item><term>Use the <tt>timerWithTimeInterval:invocation:repeats:</tt> or <tt>timerWithTimeInterval:target:selector:userInfo:repeats:</tt> class method to create the timer object without scheduling it on a run loop. (After creating it, you must add the timer to a run loop manually by calling the <tt>addTimer:forMode:</tt> method of the corresponding <tt>NSRunLoop</tt> object.)</term></item>
      <item><term>Allocate the timer and initialize it using the <tt>initWithFireDate:interval:target:selector:userInfo:repeats:</tt> method. (After creating it, you must add the timer to a run loop manually by calling the <tt>addTimer:forMode:</tt> method of the corresponding <tt>NSRunLoop</tt> object.)</term></item>
    </list>
    <para>Once scheduled on a run loop, the timer fires at the specified interval until it is invalidated. A non-repeating timer invalidates itself immediately after it fires. However, for a repeating timer, you must invalidate the timer object yourself by calling its <tt>invalidate</tt> method. Calling this method requests the removal of the timer from the current run loop; as a result, you should always call the <tt>invalidate</tt> method from the same thread on which the timer was installed. Invalidating the timer immediately disables it so that it no longer affects the run loop. The run loop then removes and releases the timer, either just before the <tt>invalidate</tt> method returns or at some later point. Once invalidated, timer objects cannot be reused.</para>
    <para>You should not attempt to subclass <tt>NSTimer</tt>.</para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSTimer (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSTimer (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advatnage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsability to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSTimer (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSTimer (MonoTouch.Foundation.NSDate date, TimeSpan when, MonoTouch.Foundation.NSAction action, bool repeats);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSDate date, valuetype System.TimeSpan when, class MonoTouch.Foundation.NSAction action, bool repeats) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="date" Type="MonoTouch.Foundation.NSDate" />
        <Parameter Name="when" Type="System.TimeSpan" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="repeats" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="date">Time at which the timer will be fired.</param>
        <param name="when">To be added.</param>
        <param name="action">To be added.</param>
        <param name="repeats">Whether this timer should repeat automatically (true) or will be invalidated after firing the first time (false).</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NSTimer (MonoTouch.Foundation.NSDate date, double seconds, MonoTouch.Foundation.NSObject target, MonoTouch.ObjCRuntime.Selector selector, MonoTouch.Foundation.NSObject userInfo, bool repeats);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSDate date, float64 seconds, class MonoTouch.Foundation.NSObject target, class MonoTouch.ObjCRuntime.Selector selector, class MonoTouch.Foundation.NSObject userInfo, bool repeats) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFireDate:interval:target:selector:userInfo:repeats:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="date" Type="MonoTouch.Foundation.NSDate" />
        <Parameter Name="seconds" Type="System.Double" />
        <Parameter Name="target" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="selector" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="userInfo" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="repeats" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="date">Time at which the timer will be fired.</param>
        <param name="seconds">For repeating timers, the number of seconds to wait before firing the timer again. If <em>seconds</em> is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead.</param>
        <param name="target">The object to which to send the message specified by <em>selector</em> when the timer fires. The target object is retained by the timer and released when the timer is invalidated.</param>
        <param name="selector">The message to send to <em>target</em> when the timer fires. The timer passes itself as the argument to this method.</param>
        <param name="userInfo">Custom user info for the timer. The object you specify is retained by the timer and released when the timer is invalidated. This parameter may be nil.</param>
        <param name="repeats">Whether this timer should repeat automatically (<tt>true</tt>) or will be invalidated after firing the first time (<tt>false</tt>).</param>
        <summary>Initializes a new <tt>NSTimer</tt> object using the specified object and selector.</summary>
        <remarks>TYou must add the new timer to a run loop, using <tt>addTimer:forMode:</tt>. Upon firing, the timer sends the message <em>selector</em> to target. (If the timer is configured to repeat, there is no need to subsequently re-add the timer to the run loop.)</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRepeatingScheduledTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateRepeatingScheduledTimer (double seconds, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateRepeatingScheduledTimer(float64 seconds, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Double" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="seconds">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a repeating timer with the specified parameters and schedules it for execution on the current NSRunLoop in the default mode.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRepeatingScheduledTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateRepeatingScheduledTimer (TimeSpan when, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateRepeatingScheduledTimer(valuetype System.TimeSpan when, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="when" Type="System.TimeSpan" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="when">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a repeating timer with the specified parameters and schedules it for execution on the current NSRunLoop in the default mode.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRepeatingTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateRepeatingTimer (double seconds, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateRepeatingTimer(float64 seconds, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Double" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="seconds">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a repeating timer with the specified parameters that can later be added to an NSRunLoop.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRepeatingTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateRepeatingTimer (TimeSpan when, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateRepeatingTimer(valuetype System.TimeSpan when, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="when" Type="System.TimeSpan" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="when">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a repeating timer with the specified parameters that can later be added to an NSRunLoop.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateScheduledTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateScheduledTimer (double seconds, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateScheduledTimer(float64 seconds, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Double" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="seconds">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a timer with the specified parameters and schedules it for execution on the current NSRunLoop in the default mode.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateScheduledTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateScheduledTimer (TimeSpan when, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateScheduledTimer(valuetype System.TimeSpan when, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="when" Type="System.TimeSpan" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="when">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a timer with the specified parameters that can later be added to an NSRunLoop.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateScheduledTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateScheduledTimer (double seconds, MonoTouch.Foundation.NSObject target, MonoTouch.ObjCRuntime.Selector selector, MonoTouch.Foundation.NSObject userInfo, bool repeats);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateScheduledTimer(float64 seconds, class MonoTouch.Foundation.NSObject target, class MonoTouch.ObjCRuntime.Selector selector, class MonoTouch.Foundation.NSObject userInfo, bool repeats) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Double" />
        <Parameter Name="target" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="selector" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="userInfo" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="repeats" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="seconds">The number of seconds between firings of the timer. If <em>seconds</em> is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead.</param>
        <param name="target">The object to which to send the message specified by <em>aSelector</em> when the timer fires. The target object is retained by the timer and released when the timer is invalidated.</param>
        <param name="selector">The message to send to <em>target</em> when the timer fires. The selector must correspond to a method that returns void and takes a single argument. The timer passes itself as the argument to this method.</param>
        <param name="userInfo">The user info for the timer. The object you specify is retained by the timer and released when the timer is invalidated. This parameter may be nil.</param>
        <param name="repeats">Whether this timer should repeat automatically (<tt>true</tt>) or will be invalidated after firing the first time (<tt>false</tt>).</param>
        <summary>Creates a timer with the specified parameters and schedules it for execution on the current <tt>NSRunLoop</tt> in the default mode. </summary>
        <returns>A new <tt>NSTimer</tt> object, configured according to the specified parameters.</returns>
        <remarks>After <em>seconds</em> seconds have elapsed, the timer fires, sending the message <em>aSelector</em> to <em>target</em>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateTimer (double seconds, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateTimer(float64 seconds, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Double" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="seconds">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a timer object that can be later added to an NSRunLoop.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateTimer (TimeSpan when, MonoTouch.Foundation.NSAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateTimer(valuetype System.TimeSpan when, class MonoTouch.Foundation.NSAction action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="when" Type="System.TimeSpan" />
        <Parameter Name="action" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="when">To be added.</param>
        <param name="action">To be added.</param>
        <summary>Creates a timer object that can be later added to an NSRunLoop.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSTimer CreateTimer (double seconds, MonoTouch.Foundation.NSObject target, MonoTouch.ObjCRuntime.Selector selector, MonoTouch.Foundation.NSObject userInfo, bool repeats);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.Foundation.NSTimer CreateTimer(float64 seconds, class MonoTouch.Foundation.NSObject target, class MonoTouch.ObjCRuntime.Selector selector, class MonoTouch.Foundation.NSObject userInfo, bool repeats) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("timerWithTimeInterval:target:selector:userInfo:repeats:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSTimer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Double" />
        <Parameter Name="target" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="selector" Type="MonoTouch.ObjCRuntime.Selector" />
        <Parameter Name="userInfo" Type="MonoTouch.Foundation.NSObject" />
        <Parameter Name="repeats" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="seconds">The number of seconds between firings of the timer. If <em>seconds</em> is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead.</param>
        <param name="target">The object to which to send the message specified by <em>aSelector</em> when the timer fires. The target object is retained by the timer and released when the timer is invalidated.</param>
        <param name="selector">The message to send to target when the timer fires. The timer passes itself as the argument to this method.</param>
        <param name="userInfo">Custom user info for the timer. The object you specify is retained by the timer and released when the timer is invalidated. This parameter may be nil.</param>
        <param name="repeats">Whether this timer should repeat automatically (true) or will be invalidated after firing the first time (false).</param>
        <summary>Creates a timer object that can be later added to an NSRunLoop.</summary>
        <returns>A new <tt>NSTimer</tt> object, configured according to the specified parameters.</returns>
        <remarks>You must add the new timer to a run loop, using <tt>addTimer:forMode:</tt>. Then, after <em>seconds</em> seconds have elapsed, the timer fires, sending the message <em>selector</em> to <em>target</em>. (If the timer is configured to repeat, there is no need to subsequently re-add the timer to the run loop.)</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resourced used by the NSTimer object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the NSTimer class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposting <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the NSTimer ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fire">
      <MemberSignature Language="C#" Value="public virtual void Fire ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Fire() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("fire")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FireDate">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSDate FireDate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSDate FireDate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("fireDate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setFireDate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSDate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Resets the firing time of the receiver to the specified date.</summary>
        <value>To be added.</value>
        <remarks><para>You typically use this method to adjust the firing time of a repeating timer. Although resetting a timer’s next firing time is a relatively expensive operation, it may be more efficient in some situations. For example, you could use it in situations where you want to repeat an action multiple times in the future, but at irregular time intervals. Adjusting the firing time of a single timer would likely incur less expense than creating multiple timer objects, scheduling each one on a run loop, and then destroying them.</para>
        <para>You should not call this method on a timer that has been invalidated, which includes non-repeating timers that have already fired. You could potentially call this method on a non-repeating timer that had not yet fired, although you should always do so from the thread to which the timer is attached to avoid potential race conditions.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public virtual void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Invalidate() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("invalidate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops the receiver from ever firing again and requests its removal from its run loop.</summary>
        <remarks>
        <para>This method is the only way to remove a timer from an <tt>NSRunLoop</tt> object. The <tt>NSRunLoop</tt> object removes and releases the timer, either just before the <tt>invalidate</tt> method returns or at some later point.</para>
        <para>If it was configured with target and user info objects, the receiver releases its references to those objects as well.</para>
        <para>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public virtual bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isValid")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a Boolean value that indicates whether the receiver is currently valid.</summary>
        <value>To be added.</value>
        <remarks><tt>true</tt> if the receiver is still capable of firing or <tt>false</tt> if the timer has been invalidated and is no longer capable of firing.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeInterval">
      <MemberSignature Language="C#" Value="public virtual double TimeInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 TimeInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("timeInterval")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the receiver’s time interval.</summary>
        <value>The receiver’s time interval. If the receiver is a non-repeating timer, returns 0 (even if a time interval was set).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("userInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the receiver's <em>userInfo</em> object.</summary>
        <value>The receiver's <em>userInfo</em> object.</value>
        <remarks>Do not invoke this method after the timer is invalidated. Use <tt>isValid</tt> to test whether the timer is valid.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
