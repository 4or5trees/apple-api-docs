<Type Name="UIKeyboard" FullName="MonoTouch.UIKit.UIKeyboard">
  <TypeSignature Language="C#" Value="public class UIKeyboard" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIKeyboard extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Access to the iPhone virtual keyboard.</summary>
    <remarks>To be added.</remarks>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIKeyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationCurveFromNotification">
      <MemberSignature Language="C#" Value="public static uint AnimationCurveFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 AnimationCurveFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationCurveUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString AnimationCurveUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString AnimationCurveUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationDurationFromNotification">
      <MemberSignature Language="C#" Value="public static double AnimationDurationFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 AnimationDurationFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationDurationUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString AnimationDurationUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString AnimationDurationUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BoundsFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.RectangleF BoundsFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.RectangleF BoundsFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in iOS 3.2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BoundsUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString BoundsUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString BoundsUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterBeginFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.PointF CenterBeginFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.PointF CenterBeginFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in iOS 3.2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterBeginUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString CenterBeginUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString CenterBeginUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterEndFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.PointF CenterEndFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.PointF CenterEndFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in iOS 3.2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CenterEndUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString CenterEndUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString CenterEndUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DidChangeFrameNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidChangeFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidChangeFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidChangeFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKeyboard+Notifications" />.<see cref="M:UIKeyboard+Notifications.ObserveDidChangeFrame" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidChangeFrame ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, DidChangeFrame args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidChangeFrameNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidChangeFrameNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidHideNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidHideNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidHideNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidHide</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKeyboard+Notifications" />.<see cref="M:UIKeyboard+Notifications.ObserveDidHide" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidHide ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, DidHide args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidHide (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidHideNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidHideNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidShowNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString DidShowNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString DidShowNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for DidShow</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKeyboard+Notifications" />.<see cref="M:UIKeyboard+Notifications.ObserveDidShow" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveDidShow ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, DidShow args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveDidShow (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.DidShowNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.DidShowNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameBeginFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.RectangleF FrameBeginFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.RectangleF FrameBeginFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameBeginUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString FrameBeginUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString FrameBeginUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameEndFromNotification">
      <MemberSignature Language="C#" Value="public static System.Drawing.RectangleF FrameEndFromNotification (MonoTouch.Foundation.NSNotification n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.RectangleF FrameEndFromNotification(class MonoTouch.Foundation.NSNotification n) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n" Type="MonoTouch.Foundation.NSNotification" />
      </Parameters>
      <Docs>
        <param name="n">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameEndUserInfoKey">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString FrameEndUserInfoKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString FrameEndUserInfoKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WillChangeFrameNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillChangeFrameNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillChangeFrameNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillChangeFrame</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKeyboard+Notifications" />.<see cref="M:UIKeyboard+Notifications.ObserveWillChangeFrame" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillChangeFrame ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, WillChangeFrame args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillChangeFrame (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillChangeFrameNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillChangeFrameNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillHideNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillHideNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillHideNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillHide</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKeyboard+Notifications" />.<see cref="M:UIKeyboard+Notifications.ObserveWillHide" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillHide ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, WillHide args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillHide (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillHideNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillHideNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillShowNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString WillShowNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString WillShowNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for WillShow</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UIKeyboard+Notifications" />.<see cref="M:UIKeyboard+Notifications.ObserveWillShow" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UIKeyboard.Notifications.ObserveWillShow ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, WillShow args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);

    Console.WriteLine ("FrameBegin", args.FrameBegin);
    Console.WriteLine ("FrameEnd", args.FrameEnd);
    Console.WriteLine ("AnimationDuration", args.AnimationDuration);
    Console.WriteLine ("AnimationCurve", args.AnimationCurve);
}

void Setup ()
{
    notification = UIKeyboard.Notifications.ObserveWillShow (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UIKeyboard.WillShowNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UIKeyboard", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UIKeyboard", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UIKeyboard.WillShowNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
