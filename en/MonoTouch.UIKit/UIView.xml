<Type Name="UIView" FullName="MonoTouch.UIKit.UIView">
  <TypeSignature Language="C#" Value="public class UIView : MonoTouch.UIKit.UIResponder, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIView extends MonoTouch.UIKit.UIResponder implements class System.Collections.IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.UIKit.UIResponder</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Base class used for components that want to render themselves and respond to events.</summary>
    <remarks>
      <para>
        The UIView class is a rectangular area on the screen that is
        responsible for displaying content and handling user interactions
        with that content. It can also contain other views, allowing you to
        create complex interactive controls.  UIView can thus be used as
        either a standalone control, or a full screen of content built from
        many other independent UIViews. 
      </para>
      <para>Views have three major responsibilities:</para>
      <list type="bullet">
        <item>
          <term>
            Visualization: UIView instances are responsible for displaying
            their content, typically this is done by implementing a draw
            method using either <see cref="N:MonoTouch.CoreGraphics" />,
            OpenGL or customizing some of their visual properties.  Views 
            also have built-in support for animating elements of the view.  
          </term>
        </item>
        <item>
          <term>
            Managing Layout and Subviews: UIViews are responsible for
            managing their layout in response to changes in size and
            orientation. This includes re-drawing any content they manage,
            as well as repositioning children views. This is most often in
            response to size of the UIView. For instance, if a view
            represents a button, the location of corners would change
            according to size. Or, if the device was rotated, the view might
            get resized (or it might resize it's child views).
          </term>
        </item>
        <item>
          <term>
      
            Event Handling: UIViews are a natural place to handle touch
            events since they are self-contained user interface elements.
            UIViews subclass the <see cref="T:MonoTouch.UIKit.UIResponder" />
            class, so they participate both on system events (like motion
            and actions) as well as being able to process touch events.
      
          </term>
        </item>
      </list>
      <format type="text/html">
        <h2>Event Handling</h2>
      </format>
      <para>
        UIViews can handle touch events in two ways.  You can use the
        high-level gesture recognizer API to detect and handle gestures, or
        you can roll your own event handling by using the low-level
        interface that provides detailed touch events as they happen: every
        time a finger touches the screen or is lifted as well as motion of
        those fingers.  Both are covered below
      </para>
      <para>
        When your UIView wants to respond to user input by updating its
        display, it should call the
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()" /> or
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" /> which will queue a call to your
        <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" /> method
        where you would re-render your control with the new state.
      </para>
      <para>
        Event delivery can be turned off either by setting the
        <see cref="P:MonoTouch.UIKit.UIView.UserInteractionEnabled" /> to false or you can
        disable them temporarily at the application level by calling
        <see cref="M:MonoTouch.UIKit.UIApplication.BeginIgnoringInteractionEvents" />.  In
        both cases, events destined for the view are dropped and are not
        delivered to the views.
      </para>
      <para>
        Events are disabled while animation are playing back.  You can
        change this behavior when using explicit animations by using the
        <see cref="T:MonoTouch.UIKit.UIViewAnimationOptions" />'s AllowUserInteraction
        flag in your animation.
      </para>
      <format type="text/html">
        <h3>Event Handling with Gesture Recognizers</h3>
      </format>
      <para>
        Interacting with touch interfaces has lead to a series of common
        gesture idioms that are used everywhere.  Gestures like swiping,
        panning, long-presses, pinching rotating and tapping.  iOS makes the
        process of detecting these common gesture idioms very easy by
        providing Gesture Recognizers.  These are objects that inherit from
        the UIGestureRecognizer class and can detect various standard
        gesture idioms.  The built-in recognizers include:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UILongPressGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIPanGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIPinchGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UIRotationGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UISwipeGestureRecognizer" />
          </term>
        </item>
        <item>
          <term>
            <see cref="T:MonoTouch.UIKit.UITapGestureRecognizer" />
          </term>
        </item>
      </list>
      <para>
        In addition, you can create your own custom gesture recognizer by
        subclassing <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" />.
      </para>
      <para>
        To use the recognizer, you need to create an instance of the
        specific kind of recognizer that you need, optionally set some
        parameters and then you add it to the view by calling
        AddGestureRecognizer.  It is possible to attach multiple gesture
        recognizers to a single view.
      </para>
      <para>
        For example, the following code create a gesture recognizer that
        detects a panning gesture and assigns it to myView:
      
      </para>
      <example>
        <code lang="c#">
var recognizer = new UIPanGestureRecognizer ((g) =&gt; {
	Console.WriteLine ("Panning detected");
	Console.WriteLine ("Gesture recognizer state: {0}", g.State);
});
      
myView.AddGestureRecognizer (recognizer);
        </code>
      </example>
      <para>
        The parameter passed to your lambda (in this case the "g" parameter)
        is an instance of the gesture recognizer that detected the gesture.
        You can query the parameters of the recognized query by looking at
        the properties in the recognizer, the
        <see cref="P:MonoTouch.UIKit.UIGestureRecognizer.State" /> property contains the
        recognizer state.
      
      </para>
      <format type="text/html">
        <h3>Event Handling with method Overrides</h3>
      </format>
      <para>
        Although Gesture Recognizers provide a high-level and convenient way
        of capturing many touch events, they do not cover every
        possibility. For those cases, developers should subclass UIView and
        override one or more of the following methods inherited from
        UIResponder:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
            sent when one or more fingers touch the screen.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
             sent when one or more fingers move.
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
             sent when one or more fingers are lifted from the screen.
           </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />:
            sent when the touch is cancelled by the system (for example if
            the phone interrupts your application).
          </term>
        </item>
      </list>
      <para>
        UIViews by default only handle a single touch event at once.  If you
        want your view to handle multiple touches, you must set the
        <see cref="P:MonoTouch.UIKit.UIView.MultipleTouchEnabled" /> to true.
      </para>
      <para>
      
        iOS creates a T:MonoTouch.UIKit.UIEvent object any time a finger
        touches the screen, moves or is removed from the screen.  The <see cref="T:MonoTouch.UIKit.UIEvent" /> encapsulates all of the touches
        that are taking place on the screen at this point, even those that
        do not belong to this view.  In addition to the <see cref="T:MonoTouch.UIKit.UIEvent" />, there is an <see cref="T:MonoTouch.Foundation.NSSet" /> containing <see cref="T:MonoTouch.UIKit.UITouch" /> objects that represent the state
        of each finger on the screen for this particular view.
      </para>
      <para>
      
        If your application handles touches directly, you might want to
        override the <see cref="M:MonoTouch.UIKit.UIView.GestureRecognizerShouldBegin(MonoTouch.UIKit.UIGestureRecognizer)" />
        method to control whether an associated
        <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" /> should execute or not.
      
      </para>
      <format type="text/html">
        <h2>Creating Views</h2>
      </format>
      <para>
        UIViews are typically created by invoking the constructor that takes
        a frame as its parameter (the frame is of type
        <see cref="T:System.Drawing.RectangleF" />), for example:
      </para>
      <example>
        <code lang="c#">
var myView = new UIView (new RectangleF (0, 0, 100, 100));
        </code>
      </example>
      <para>
        Most subclasses of UIView will provide a constructor that takes the
        initial frame, just like UIView.  For more information on how to do
        this for your own subclasses, see the section below on subclassing
        UIView.
      </para>
      <para>
        You will want to configure your view at this point.  One of the most
        important properties to configure is the
        <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> which determines how the
        view will be resized if you invoke
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsLayout()" /> or if the geometry of the
        view container changes (for example, in response to a device
        rotation).
      </para>
      <para>
        Once you have created a view, you will add it to a container view.
        For your main screen this could be a UIWindow or it could be the
        <see cref="P:MonoTouch.UIKit.UIViewController.View" /> property of your current
        <see cref="T:MonoTouch.UIKit.UIViewController" />, this is done using one of the
        following methods:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.AddSubview(MonoTouch.UIKit.UIView)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubview(MonoTouch.UIKit.UIView, int)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewAbove(MonoTouch.UIKit.UIView, MonoTouch.UIKit.UIView)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.InsertSubviewBelow(MonoTouch.UIKit.UIView, MonoTouch.UIKit.UIView)" />
          </term>
        </item>
      </list>
      <para>
        Although you can use the above APIs to add subviews to any
        UIView, Apple advises developers against extending
        existing high-level views by adding subviews to them behind their
        back.  Instead developers should use the public API those high-level
        views expose.
      </para>
      <format type="text/html">
        <h2>Bounds and Sizes</h2>
      </format>
      <para>
        Each view is created with an initial <see cref="P:MonoTouch.UIKit.UIView.Frame" />.  The Frame is a
        <see cref="T:System.Drawing.RectangleF" /> structure that represents both the size and the initial
        position for the view.  The coordinates for the Frame are used to
        specify the position relative to its superview.
      </para>
      <para>
        You can resize and move views around using the frame.  Every time
        you set the frame the view will layout its subviews. If you are
        purely moving the view, using frame can cause performance issues, as
        it relays out the view and all its subviews.
      </para>
      <para>
        The <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> is the usable
        frame of the view.  Unlike the <see cref="P:MonoTouch.UIKit.UIView.Frame" />, the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> do not use the container's
        coordinate space, but instead represent the size in the view's own
        coordinate space.  By default the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> location is (0,0).
      </para>
      <para>
      
        When you update the <see cref="P:MonoTouch.UIKit.UIView.Bounds" />
        property, it will modify the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> based on the value of the
        <see cref="P:MonoTouch.UIKit.UIView.Center" />.  You can also change
        the position of your view by updating the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
      
      </para>
      <para>
        When the <see cref="P:MonoTouch.UIKit.UIView.Bound" /> property is changed, the size of the view is affected
        relative to the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
      </para>
      <format type="text/html">
        <h2>Animation</h2>
      </format>
      <para>
        There are two styles of animations supported by UIViews, implicit
        animations and explicit animations.
      </para>
      <para>
        Implicit animations happen automatically when you modify the <see cref="P:MonoTouch.UIKit.UIView.Frame" />, <see cref="P:MonoTouch.UIKit.UIView.Bounds" />, <see cref="P:MonoTouch.UIKit.UIView.Center" />, <see cref="P:MonoTouch.UIKit.UIView.Transform" />, <see cref="P:MonoTouch.UIKit.UIView.Alpha" />, <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor" /> or <see cref="P:MonoTouch.UIKit.UIView.ContentStretch" /> properties in a
        view.  The system will automatically animate the change using the
        system defaults.  When you modify any of these animatable properties
        in the view, iOS automatically creates an animation transaction
        which starts as soon as control returns to the main loop.
      </para>
      <para>
        For example, the following code will animate a view's <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> and
        <see cref="P:MonoTouch.UIKit.UIView.Center" /></para>
      <example>
        <code lang="c#">

view.Bounds = new RectangleF (0, 0, 100, 100);
view.Center = new PointF (200, 200);
	</code>
      </example>
      <para>
        Alternatively, you can create animations explicitly by calling the
        <see cref="M:MonoTouch.UIKit.UIView..BeginAnimations(string)" /> method, configuring the animation, making the
        changes to the animatable properties and then completing the
        transaction by calling <see cref="M:MonoTouch.UIKit.UIView.CommitAnimations()" />.
      </para>
      <para>
        Once you call <see cref="M:MonoTouch.UIKit.UIView.BeginAnimations(string)" />, you can
        call these methods to configure the animation:
      </para>
      <list type="bullet">
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDuration(double)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationCurve(MonoTouch.UIKit.UIViewAnimationCurve)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelay(double)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationRepeatAutoReverses(bool)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationRepeatCount(float)" />
          </term>
        </item>
        <item>
          <term>
            <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDidStopSelector(MonoTouch.ObjCRuntime.Selector)" />
          </term>
        </item>
      </list>
      <para>
        The following example shows how to use these methods in a
        transaction:
      </para>
      <example>
        <code lang="c#">
      UIView.BeginAnimations (null);
      UIView.SetAnimationDuration (5);
      UIView.SetAnimationCurve (UIViewAnimationCurve.EaseOut);
      view.Bounds = new RectangleF (0, 0, 100, 100);
      view.Position = new PointF (200, 200);
      UIView.CommitAnimations ();
        </code>
      </example>
      <para>
        An alternative to create the transactions and set the configuration
        options is to use the new <see cref="M:MonoTouch.UIKit.UIView.Animate" /> collection of methods that
        allow you to specify in a single call the delay, the duration, the
        animation block and an action to be invoked when the animation
        completes:
      </para>
      <example>
        <code lang="c#">
      UIView.Animate (duration, delay, UIViewAnimationOption.Autoreverse,
      	delegate {
      		view.Bounds = new RectangleF (0, 0, 100, 100);
      		view.Position = new PointF (200, 200);
      	},
      	delegate {
      		Console.WriteLine ("Animation completed");
      	}
      );
        </code>
      </example>
      <para>
        The above is the basic set of animations supported by UIViews.  If
        you want finer control over animations you can resort to animations
        done directly using <see cref="N:MonoTouch.CoreAnimation" />.  <see cref="N:MonoTouch.CoreAnimation" /> allows you to
        animate layers and properties of your C# objects.
      </para>
      <format type="text/html">
        <h2>Threading</h2>
      </format>
      <para>
        UIView methods are not thread safe, so you should avoid configuring
        or invoking any of the UIView static methods from any thread that is
        not the main thread.  Newer versions of MonoTouch catch these
        mistakes in Debug builds by throwing an exception.  See the
        <see cref="F:MonoTouch.UIKit.UIApplication.CheckForIllegalCrossThreadCalls" /> for
        more information.
      </para>
      <para>
        If you want to perform some work in a background thread that must
        update any of the UIView properties or you want to invoke any of the
        UIView static methods, you should use either the
        <see cref="M:MonoTouch.Foundation.NSObject.BeginInvokeOnMainThread()" /> or
        <see cref="M:MonoTouch.Foundation.NSObject.InvokeOnMainThread()" /> methods.  Both
        methods take a C# delegate or lambda that is invoked on the main
        thread.
      </para>
      <para>
        The <see cref="M:MonoTouch.Foundation.NSObject.InvokeOnMainThread()" /> method will
        invoke the specified delegate method synchronously on the main
        thread. The
        <see cref="M:MonoTouch.Foundation.NSObject.BeginInvokeOnMainThread()" /> will queue
        the action to be executed on the main thread.
      </para>
      <para>
      Example:
      </para>
      <example>
        <code lang="c#">
//
// This performs an expensive computation in the background, and then
// updates the main UI when done.
//
void DoSomeWork (UIView view)
{
	double sum = 0;
	for (int i = 0; i &lt; Int32.MaxValue; i++)
		sum += i * i;

	// Now invoke the update on the main UI.
	view.BeginInvokeOnMainThread (delegate {
		view.BackgroundColor = UIColor.Green;
		statusLabel.Text = "Sum is: " + sum;
	});
}
        </code>
      </example>
      <para>
        The following example shows a helper method that can be used to run
        the provided action on the main thread.  It optimizes for the case
        where you are calling this from the main thread already, and avoids
        a trip to the main loop pump:
      </para>
      <example>
        <code lang="c#">
static NSObject Invoker = new NSObject();
public static void EnsureInvokedOnMainThread (Action action)
{
      	if (NSThread.Current.IsMainThread) {
      		action ();
      		return;
      	}
      	Invoker.BeginInvokeOnMainThread (() =&gt; action());
}
        </code>
      </example>
      <format type="text/html">
        <h2>How to Subclass UIView</h2>
      </format>
      <para>
        Developers will often subclass UIView to provide their own custom
        views to use.  This section discusses the different classes of
        members that developers would overwrite to create their custom
        classes.
      </para>
      <format type="text/html">
        <h3>Initialization</h3>
      </format>
      <para>
        Your subclass of UIView should chain into either the UIView
        constructor that is initialized with an initial frame (<see cref="C:MonoTouch.UIKit.UIView(System.Drawing.RectangleF)" />).  You
        would typically do this like this:
      </para>
      <example>
        <code lang="c#">
public class MyView : UIView {
          public MyView (RectangleF frame) : base (frame)
          {
             // Your initialization code goes here
          }
}
         </code>
      </example>
      <para>
        If your object will be deserialized from an archive produced by the
        UI designer, you would need to chain to the <see cref="C:MonoTouch.UIKit.UIView(MonoTouch.Foundation.NSCoder)" />
        constructor and also flag the constructor as being the one
        implementing the selector "initWithCoder:", like this:
      </para>
      <example>
        <code lang="c#">
public class MyView : UIView {
          [Export ("initWithCoder:")]
          public MyView (NSCoder coder) : base (coder)
          {
             // Your initialization code goes here
          }
}
         </code>
      </example>
      <para>
        By default UIViews will use a <see cref="T:MonoTouch.CoreAnimation.CALayer" /> instance for their
        backing store.  The section on "Changing the CALayer" below has both
        information on how to make this change and a sample.
      </para>
      <para>
        If your view will contains any other subviews, you should initialize
        those values in your constructor.
      </para>
      <format type="text/html">
        <h3>Custom Drawing</h3>
      </format>
      <para>
        To implement custom drawing code in a view, you can subclass the
        UIView and override the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
        method. The drawing code placed in the Draw method can use <see cref="N:MonoTouch.CoreGraphics" /> to draw with. The steps to draw
        with Core Graphics are:
      </para>
      <list type="bullet">
        <item>
          <term>Obtain a reference to the current graphics context.</term>
        </item>
        <item>
          <term>Set up any desired drawing attributes, such as fill and stroke colors for instance.</term>
        </item>
        <item>
          <term>Create geometry from Core Graphics primitives.</term>
        </item>
        <item>
          <term>Draw the geometry.</term>
        </item>
      </list>
      <para>
        For example, the following code shows an implementation of an
        overridden Draw method that draws a triangle:
      </para>
      <example>
        <code lang="c#">
public override void Draw (RectangleF rect)
{
	base.Draw (rect);
		
	var context = UIGraphics.GetCurrentContext ();
		
	context.SetLineWidth(4);
	UIColor.Red.SetFill ();
	UIColor.Blue.SetStroke ();
	
	var path = new CGPath ();

	path.AddLines(new PointF[]{
		new PointF(100,200),
		new PointF(160,100), 
		new PointF(220,200)});
		
	path.CloseSubpath();
		
	context.AddPath(path);		
	context.DrawPath(CGPathDrawingMode.FillStroke);
}
        </code>
      </example>
      <para>
        The <see cref="M:MonoTouch.UIKit.UIView.Draw" /> method should never be called directly. It is called by iOS
        during run loop processing. The first time through the run loop, it
        is called. After that, it will be called on demand whenever the view
        has been marked as needing display by calling <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()" /> or
        <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" />.
      </para>
      <para>
        Core Graphics uses device independent points rather than
        pixels. This allows drawing code to scale between different
        resolutions. For example, on a Retina display, 1 point is equivalent
        to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
        pixel.
      </para>
      <format type="text/html">
        <h3>Printing</h3>
      </format>
      <para>
        UIViews can be printed.  The default behavior is for the contents of
        the UIView as rendered by the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
        method to be printed.
      </para>
      <para>
        If you need to provide a different rendering for the view when
        printed, you should override the <see cref="M:MonoTouch.UIKit.UIView.DrawRect(System.Drawing.RectangleF,MonoTouch.UIKit.UIView.UIViewPrintFormatter)" />
        method.
      </para>
      <format type="text/html">
        <h3>Constraints</h3>
      </format>
      <para>
        If you want your view subclass to use the new constraint-based
        layout system introduced with iOS 6.0, your subclass needs to
        respond to the requiresConstraintBasedLayout selector, like this:
      </para>
      <example>
        <code lang="c#">
class MyView : UIView {
      	[Export ("requiresConstraintBasedLayout")]
      	bool UseNewLayout ()
      	{
      		return true;
      	}
}
        </code>
      </example>
      <para>
        If your view will use constraints among its own subviews to lay them
        out, you should override the <see cref="M:P:MonoTouch.UIKit.UIView.UpdateConstraints" /> which is
        called before the constraints-based layout is performed.
      </para>
      <para>
      
        Constraints-based layout is performed on the alignment rectangle
        instead of the view's <see cref="P:MonoTouch.UIKit.UIView.Frame" />.
        The alignment rectangle by default is computed as the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> modified by the <see cref="P:MonoTouch.UIKit.UIView.AlignmentRectInsets" />.  You can
        change that behavior and provide your own alignment rectangle by
        overriding the <see cref="M:MonoTouch.UIKit.UIView.AlignmentRectForFrame(System.Drawing.RectangleF)" />
        and <see cref="M:MonoTouch.UIKit.UIView.FrameForAlignmentRect(System.Drawing.RectangleF)" />
        methods.
      </para>
      <format type="text/html">
        <h3>Layout</h3>
      </format>
      <para>
        The default layout system for UIViews is very simple.  UIViews are
        created with an initial <see cref="P:MonoTouch.UIKit.UIView.Frame" />
        and an <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> that
        determines how the view will be resized in response to changes in
        the container's boundaries.
      </para>
      <para>
        You should set the default <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> property after
        initialization.
      </para>
      <para>
        If your view will be a container for other views, you should
        configure their <see cref="P:MonoTouch.UIKit.UIView.AutoresizingMask" /> property.  If the
        layout behavior provided is not sufficient, you should override the
        <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" /> method.
        This method is responsible for updating the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> property of each of the
        subviews.
      </para>
      <para>
        If the state of your view changes in response to some API calls,
        instead of changing the layout manually in response to the change,
        you should invoke the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsLayout()" /> method which will
        flag the view for a layout.  The layout event will then be processed
        the next time the main loop runs.  By using this approach, you can
        coalesce multiple changes to the layout in a single pass.
      </para>
      <para>
        UIViews can implement the <see cref="M:MonoTouch.UIKit.UIView.SizeThatFits(System.Drawing.SizeF)" />
        method to report back what is their desired size based on the
        contents of the view.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.SubviewAdded(MonoTouch.UIKit.UIView)" />
        and the <see cref="M:MonoTouch.UIKit.UIView.WillRemoveSubview(MonoTouch.UIKit.UIView)" />
        to track when subviews are added or removed to your UIView.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.WillMoveToWindow(MonoTouch.UIKit.UIWindow)" />
        and the <see cref="M:MonoTouch.UIKit.UIView.MovedToWindow()" /> to
        track when your view is moved from one <see cref="T:MonoTouch.UIKit.UIWindow" /> to another.
      </para>
      <para>
        You can override the <see cref="M:MonoTouch.UIKit.UIView.WillMoveToSuperview(MonoTouch.UIKit.UIView)" />
        and the <see cref="M:MonoTouch.UIKit.UIView.MovedToSuperview()" /> to
        track when your view is added or removed from a superview.
      </para>
      <format type="text/html">
        <h2>Constraints Based Layout</h2>
      </format>
      <para>
        Starting with iOS 6.0 there is a new layout system available to
        developers, the constraints-based layout system.  This system
        differs from the traditional layout system in that it uses rules
        (constraints) that describe the relationships between subviews that
        should be preserved.  When views change in size (for example a label
        is updated) or the size of the container changes (for example, after
        a rotation), the new positions and sizes for the subviews are
        computed based on these constraints.
      </para>
      <para>
        To opt into this system, a subclass of UIView should expose a static
        method that is exported as "requiresConstraintBasedLayout" and
        returns true, like this:
      </para>
      <example>
        <code lang="c#">
      class MyView : UIView {
      	[Export ("requiresConstraintBasedLayout")]
      	static bool RequiresConstraintBasedLayout ()
      	{
      		return true;
      	}
      }
        </code>
      </example>
      <format type="text/html">
        <h3>Event Handling</h3>
      </format>
      <para>
        If you are using gesture recognizers, you can add those directly to
        your constructor at initialization time.
      </para>
      <para>
        For the low-level touch event handling, you should override the <see cref="M:MonoTouch.UIKit.UIResponder.TouchesBegan(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesMoved(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" />, <see cref="M:MonoTouch.UIKit.UIResponder.TouchesEnded(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" /> and <see cref="M:MonoTouch.UIKit.UIResponder.TouchesCancelled(MonoTouch.Foundation.NSSet,MonoTouch.UIKit.UIEvent)" /> methods.
      </para>
      <para>
        You do not need to call the base methods for any of the above
        methods if you are overriding UIView directly.  But you might want
        to call base if you are deriving from another UIView subclass.
      </para>
      <para>
        You can control whether a gesture recognizer is activated by
        overriding the <see cref="M:MonoTouch.UIKit.UIViewGestureRecognizerShouldBegin(MonoTouch.UIKit.UIGestureRecognizer)" />
        method.
      </para>
      <format type="text/html">
        <h2>Views and CALayers</h2>
      </format>
      <para>
        Each UIView is backed by a <see cref="N:MonoTouch.CoreAnimation" /> Layer (<see cref="MonoTouch.CoreAnimation.CALayer" />).  A CALayer
        represents the GPU-backed bitmap that is used to render your view
        into the screen.  When you paint into a UIView, you are actually
        painting into the CALayer.
      </para>
      <para>
        While the appearance of a UIView can be controlled by setting its
        <see cref="P:MonoTouch.UIKit.UIView.Frame" />, <see cref="P:MonoTouch.UIKit.UIView.Alpha" />, <see cref="P:MonoTouch.UIKit.UIView.BackgroundColor" />, or by overriding its <see cref="M:MonoTouch.UIKit.UIView.Draw" /> method, all
        those properties and functions are in fact modifying the <see cref="P:MonoTouch.CoreAnimation.CALayer" />
        owned by the view.
      </para>
      <para>
        The <see cref="MonoTouch.UIKit.UIView.Layer" /> property is a reference to the
        CALayer owned by the view. You can change the appearance of the view
        by modifying the properties of that layer.
      </para>
      <para>
        For example, you can add rounded corners to the UIView by modifying
        the <see cref="P:MonoTouch.CoreAnimation.CALayer.CornerRadius" /> of its layer:
      </para>
      <example>
        <code lang="c#">
      view.Layer.CornerRadius = 4;
        </code>
      </example>
      <para>
        You can add drop shadows by modifying a variety of properties:
      </para>
      <example>
        <code lang="c#">
      	view.Layer.ShadowColor = new CGColor (1, 0, 0);
      	view.Layer.ShadowOpacity = 1.0f;
      	view.Layer.ShadowOffset = new SizeF (0, 4);
        </code>
      </example>
      <para>
        You can even apply a 3D transformation to the layer:
      </para>
      <example>
        <code lang="c#">
      	view.Layer.Transform = CATransform3D.MakeRotation (
      		(float)(Math.PI / 2), 1, 1, 1);
        </code>
      </example>
      <para>
        Note that this transformation is a full 3D transform, with a
        perspective element, that is more versatile than UIView's 2D
        Transform property.   If you apply 3D transforms, you should no longer use the Frame property
      </para>
      <format type="text/html">
        <h3>Changing the CALayer</h3>
      </format>
      <para>
        The <see cref="P:MonoTouch.UIKit.UIView.Layer" /> owned by a view is automatically
        created and assigned to the view by UIKit and it defaults to be a
        <see cref="T:MonoTouch.CoreAnimation.CALayer" /> instance.   You can control the type
        of layer that is created for a view by responding to the "layerClass" 
        selector in a static method.
      </para>
      <para>
        Here is an example of a UIView subclass that uses a custom <see cref="T:MonoTouch.CoreAnimation.CALayer" /> to do its drawing. This
        layer, and therefore the view, always displays the color blue:
      </para>
      <example>
        <code lang="c#">
public class BlueView : UIView
{
      	[Export ("layerClass")]
      	public static Class GetLayerClass ()
      	{
      		return new Class (typeof (BlueLayer));
      	}

      	public override void Draw (RectangleF rect)
      	{
      		// Do nothing, the Layer will do all the drawing
      	}
}
      
public class BlueLayer : CALayer
{
      	public override void DrawInContext (CGContext ctx)
      	{
      		ctx.SetFillColor (0, 0, 1, 1);
      		ctx.FillRect (Bounds);
      	}
}
        </code>
      </example>
      <para>
        In this example, a new UIView class called "BlueView" is created. It
        exports a static method called "GetLayerClass" that tells UIKit the
        type of layer that this view wishes to own. In this example, the
        BlueView wishes to own a BlueLayer.
      </para>
      <para>
        It is now up to the BlueLayer to provide the visual representation
        of the view. It does this by executing CoreGraphics drawing code in
        its <see cref="M:MonoTouch.CoreAnimation.CALayer.DrawInContext(MonoTouch.CoreGraphics.CGContext)" />
        method. This method is very similar to a UIView's Draw method but is used to fill the layer.
      
      </para>
      <para>
        Even though the BlueLayer will do all drawing for the BlueView, the
        view must still override its Draw method. This override should do
        nothing and is just a signal to UIKit that the Layer will do all the
        work.
      </para>
    </remarks>
    <related type="recipe" href="http://docs.xamarin.com/ios/Recipes/Animation/CoreAnimation/Animate_a_UIView_using_UIKit">Animate a UIView using UIKit</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advantage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsibility to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (System.Drawing.RectangleF frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UIView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programmatically create a new instance of UIView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIView (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">The subview to add.</param>
        <summary>This is an alias for AddSubview, but uses the Add pattern as it allows C# 3.0 constructs to add subviews after creating the object.</summary>
        <remarks>
          <para>
	    This method is equivalent to AddSubview and is present to enable C# 3.0 to add subviews at creation time.
	  </para>
          <example>
            <code lang="c#">
var myView = new MyView (new RectangleF (0, 0, 320, 320)){
    new ImageGallery (region [0]),
    new ImageGallery (region [1]),
    new UILabel (new RectangleF (10, 10, 200, 200)){
        Text = "Images from our Trip"
    }
};
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConstraint">
      <MemberSignature Language="C#" Value="public virtual void AddConstraint (MonoTouch.UIKit.NSLayoutConstraint constraint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraint(class MonoTouch.UIKit.NSLayoutConstraint constraint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addConstraint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="MonoTouch.UIKit.NSLayoutConstraint" />
      </Parameters>
      <Docs>
        <param name="constraint">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConstraints">
      <MemberSignature Language="C#" Value="public virtual void AddConstraints (MonoTouch.UIKit.NSLayoutConstraint[] constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddConstraints(class MonoTouch.UIKit.NSLayoutConstraint[] constraints) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addConstraints:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="MonoTouch.UIKit.NSLayoutConstraint[]" />
      </Parameters>
      <Docs>
        <param name="constraints">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void AddGestureRecognizer (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddGestureRecognizer(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addGestureRecognizer:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The configured gesture recognizer to add to this view.</param>
        <summary>Adds a gesture recognizer to this view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSubview">
      <MemberSignature Language="C#" Value="public virtual void AddSubview (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddSubview(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <summary>Adds the specified view as a subview of this view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSubviews">
      <MemberSignature Language="C#" Value="public void AddSubviews (MonoTouch.UIKit.UIView[] views);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddSubviews(class MonoTouch.UIKit.UIView[] views) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="views" Type="MonoTouch.UIKit.UIView[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="views">An array of UIViews (possibly empty).</param>
        <summary>Convenience routine to add various views to a UIView.</summary>
        <remarks>
          <para>
	    This is merely a convenience routine that allows you to add a number of views in a single call
	  </para>
          <example>
            <code lang="c#">
myView.AddSubviews (label, button, entry, image1, image2);
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectForFrame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF AlignmentRectForFrame (System.Drawing.RectangleF frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF AlignmentRectForFrame(valuetype System.Drawing.RectangleF frame) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("alignmentRectForFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="frame">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlignmentRectInsets">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIEdgeInsets AlignmentRectInsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIEdgeInsets AlignmentRectInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("alignmentRectInsets")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Alpha">
      <MemberSignature Language="C#" Value="public virtual float Alpha { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Alpha" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("alpha")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAlpha:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls the transparency (alpha) value for the view.</summary>
        <value>0 to 1.</value>
        <remarks>
          <para>

	    This controls the transparency for the view.  If the value
	    is 1.0, the view is completely opaque, if the value is 0.0
	    the view is completely transparent.    
	  </para>
          <para>

	    When the value of the view is in between 0 and 1, the
	    contents of the view are composited with views that are
	    lower in the view hierarchy or the superview.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, MonoTouch.Foundation.NSAction animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class MonoTouch.Foundation.NSAction animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <summary>Animates the property changes that take place in the specificied block.</summary>
        <remarks>
          <para>
	    This uses The CurveEaseOut and TransitionNone flags for the animation.
	  </para>
          <example>
            <code lang="c#">
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (3, () =&gt; { label.Alpha = 0 });
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoke when the animation completes.</param>
        <summary>Animates the property changes that take place in the specificied block and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <para>
	    This uses The CurveEaseOut and TransitionNone flags for the animation.
	  </para>
          <example>
            <code lang="c#">
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (
	duration: 3, 
	animation: () =&gt; { view.Alpha = 0 },
	completion: () =&gt; { view.RemoveFromSuperview (); });
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Animate">
      <MemberSignature Language="C#" Value="public static void Animate (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Animate(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds for the animation.</param>
        <param name="delay">Delay before the animation begins.</param>
        <param name="options">Animation options</param>
        <param name="animation">Code containing the changes that you will apply to your view.</param>
        <param name="completion">Code that is invoke when the animation completes.</param>
        <summary>Animates the property changes that take place in the specificied block and invokes a completion callback when the animation completes.</summary>
        <remarks>
          <example>
            <code lang="c#">
// Animates hiding the label by setting the alpha to zero over three seconds.
UIView.Animate (
	duration: 3, 
	delay: 0,
	options: UIViewAnimationOptions.AllowUserInteraction,
	animation: () =&gt; { view.Alpha = 0 },
	completion: () =&gt; { view.RemoveFromSuperview (); });
	    </code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:animations:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler" />
      </Parameters>
      <Docs>
        <param name="duration">To be added.</param>
        <param name="animation">To be added.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimateNotify">
      <MemberSignature Language="C#" Value="public static void AnimateNotify (double duration, double delay, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AnimateNotify(float64 duration, float64 delay, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animateWithDuration:delay:options:animations:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="delay" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler" />
      </Parameters>
      <Docs>
        <param name="duration">To be added.</param>
        <param name="delay">To be added.</param>
        <param name="options">To be added.</param>
        <param name="animation">To be added.</param>
        <param name="completion">
          <para>The method to invoke when the animation has completed.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationsEnabled">
      <MemberSignature Language="C#" Value="public static bool AnimationsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AnimationsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("areAnimationsEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAnimationsEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationWillEnd">
      <MemberSignature Language="C#" Value="public static event MonoTouch.Foundation.NSAction AnimationWillEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class MonoTouch.Foundation.NSAction AnimationWillEnd" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will end.</summary>
        <remarks>
	  Notice that these events are only fired as long as your application does not install its own animation delegate by calling <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)" />. 
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="AnimationWillStart">
      <MemberSignature Language="C#" Value="public static event MonoTouch.Foundation.NSAction AnimationWillStart;" />
      <MemberSignature Language="ILAsm" Value=".event class MonoTouch.Foundation.NSAction AnimationWillStart" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This event is raised when the animations will start.</summary>
        <remarks>
	  Notice that these events are only fired as long as your application does not install its own animation delegate by calling <see cref="M:MonoTouch.UIKit.UIView.SetAnimationDelegate(MonoTouch.Foundation.NSObject)" />. 
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UIView/UIViewAppearance Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>Setting any appearance properties on this instance will affect the appearance of all instances of UIView.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIView.UIViewAppearance AppearanceWhenContainedIn (Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIView/UIViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView+UIViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that you want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that you can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where you can set appearance properties for instances of UIView when those instances are contained in the hierarchy specified by the <paramref name="containers" /> parameter.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#">
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
</code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:MonoTouch.UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoresizingMask">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewAutoresizing AutoresizingMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIViewAutoresizing AutoresizingMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("autoresizingMask")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAutoresizingMask:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewAutoresizing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A bitmask that specifies how the receiver should resize itself when it's super-view's bounds change.</summary>
        <value>The default value is <see cref="UIViewAutoResizing.None" />.</value>
        <remarks>
          <para>The <see cref="M:MonoTouch.UIKit.AutoResizingMask" /> is a powerful feature that handles a good deal of the complexity of resizing views, such as occurs during device rotation. However, it is not necessarily a complete solution. For instance, when using a <see cref="T:MonoTouch.UIKit.UIScrollView" />,  logic may require the <see cref="P:MonoTouch.UIKit.UIScrollView.ContentSize" /> to be resized. In such situations, application developers may subscribe to the <c>UIDeviceOrientationDidChangeNotification</c> and implement a custom method with additional resizing logic:</para>
          <example>
            <code>
//During initialization, subscribe to orientation changes              
NSNotificationCenter.DefaultCenter.AddObserver ("UIDeviceOrientationDidChangeNotification", DeviceRotated);
              
protected void DeviceRotated (NSNotification notification)
{
	//Code to resize UIScrollView.ContentSize and other custom on-rotation logic
}
            </code>
          </example>
        </remarks>
        <altmember cref="M:MonoTouch.UIKit.UIView.AutoResizingMask" />
      </Docs>
    </Member>
    <Member MemberName="AutosizesSubviews">
      <MemberSignature Language="C#" Value="public virtual bool AutosizesSubviews { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutosizesSubviews" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("autoresizesSubviews")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAutoresizesSubviews:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundColor", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBackgroundColor:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance" /> styling system.  See the <see cref="P:MonoTouch.UIKit.UIView.Appearance" /> property and the <see cref="M:MonoTouch.UIKit.UIView.AppearanceWhenContainedIn" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="animation">
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimations">
      <MemberSignature Language="C#" Value="public static void BeginAnimations (string animationID, IntPtr context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginAnimations(string animationID, native int context) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginAnimations:context:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animationID" Type="System.String" />
        <Parameter Name="context" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="animationID">
          <para>The animation identifier.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("bounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The usable frame of the view</summary>
        <value>
        </value>
        <remarks>
          <para>
	    This property represents the usable
	    frame of the view.  Unlike the <see cref="P:MonoTouch.UIKit.UIView.Frame" />, the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> do not use the container's
	    coordinate space, but instead represent the size in the view's own
	    coordinate space.  By default the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> location is
      (0,0).
	  </para>
          <para>
	    
	    When you update this property, it will modify the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> based on the value
	    of the <see cref="P:MonoTouch.UIKit.UIView.Center" />.  You
	    can also change the position of your view by updating the
	    <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
	    
	  </para>
          <para>
	    When the Bound property is changed, the size of the view is affected
	    relative to the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property.
	  </para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BringSubviewToFront">
      <MemberSignature Language="C#" Value="public virtual void BringSubviewToFront (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BringSubviewToFront(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("bringSubviewToFront:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Center">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF Center { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF Center" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("center")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setCenter:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Center of the view, in the container coordinate space.</summary>
        <value>This value is measured in points, not pixels.</value>
        <remarks>
          <para>
	    When you update this property, this will automatically
	    adjust corresponding  <see cref="P:MonoTouch.UIKit.UIView.Frame" />.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearsContextBeforeDrawing">
      <MemberSignature Language="C#" Value="public virtual bool ClearsContextBeforeDrawing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClearsContextBeforeDrawing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("clearsContextBeforeDrawing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setClearsContextBeforeDrawing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipsToBounds">
      <MemberSignature Language="C#" Value="public virtual bool ClipsToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipsToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("clipsToBounds")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setClipsToBounds:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitAnimations">
      <MemberSignature Language="C#" Value="public static void CommitAnimations ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CommitAnimations() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("commitAnimations")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.NSLayoutConstraint[] Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.NSLayoutConstraint[] Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("constraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual float ContentCompressionResistancePriority (MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentCompressionResistancePriority(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("contentCompressionResistancePriorityForAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual float ContentHuggingPriority (MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ContentHuggingPriority(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("contentHuggingPriorityForAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentMode">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewContentMode ContentMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIViewContentMode ContentMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentMode")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentMode:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewContentMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls how the cached bitmap of a view must be rendered when the view's bounds change.</summary>
        <value>
        </value>
        <remarks>
          <para>
	    This property is used to control how the cached bitmap of the UIView changes when the <see cref="P:MonoTouch.UIKit.UIView.Frame" /> or <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> properties are updated.   
	  </para>
          <para>
	    This property works in conjunction with the <see cref="P:MonoTouch.UIKit.UIView.ContentStretch" /> property.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentScaleFactor">
      <MemberSignature Language="C#" Value="public virtual float ContentScaleFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ContentScaleFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentScaleFactor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentScaleFactor:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentStretch">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ContentStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ContentStretch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in iOS 6.0", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentStretch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentStretch:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Defines an area of the view that is intended to be stretchable.</summary>
        <value>
        </value>
        <remarks>This property was deprecated in iOS 6.0.   Developers are advised to use UIImageView with a stretchable UIImage instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointFromView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointFromView (System.Drawing.PointF point, MonoTouch.UIKit.UIView fromView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointFromView(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIView fromView) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:fromView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>To be added.</para>
        </param>
        <param name="fromView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertPointToView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.PointF ConvertPointToView (System.Drawing.PointF point, MonoTouch.UIKit.UIView toView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.PointF ConvertPointToView(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIView toView) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertPoint:toView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>To be added.</para>
        </param>
        <param name="toView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectFromView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectFromView (System.Drawing.RectangleF rect, MonoTouch.UIKit.UIView fromView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectFromView(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIView fromView) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:fromView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>To be added.</para>
        </param>
        <param name="fromView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertRectToView">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF ConvertRectToView (System.Drawing.RectangleF rect, MonoTouch.UIKit.UIView toView);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF ConvertRectToView(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIView toView) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("convertRect:toView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>To be added.</para>
        </param>
        <param name="toView">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void DecodeRestorableState (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DecodeRestorableState(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("decodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resourced used by the UIView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UIView ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawRect:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>To be added.</para>
        </param>
        <summary>Draws the view within the passed-in rectangle.</summary>
        <remarks>
          <para>
	    The <see cref="M:MonoTouch.UIKit.UIView.Draw" /> method should never be called directly. It is called by iOS
	    during run loop processing. The first time through the run loop, it
	    is called. After that, it will be called on demand whenever the view
	    has been marked as needing display by calling <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()" /> or
	    <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" />.
	  </para>
          <para>
	    Core Graphics uses device independent points rather than
	    pixels. This allows drawing code to scale between different
	    resolutions. For example, on a Retina display, 1 point is equivalent
	    to 2 pixels, while on non-Retina displays, 1 point corresponds to 1
	    pixel.
	  </para>
          <example>
            <code lang="c#">
public override void Draw (RectangleF rect)
{
	base.Draw (rect);
		
	var context = UIGraphics.GetCurrentContext ();
		
	context.SetLineWidth(4);
	UIColor.Red.SetFill ();
	UIColor.Blue.SetStroke ();
	
	var path = new CGPath ();

	path.AddLines(new PointF[]{
		new PointF(100,200),
		new PointF(160,100), 
		new PointF(220,200)});
		
	path.CloseSubpath();
		
	context.AddPath(path);		
	context.DrawPath(CGPathDrawingMode.FillStroke);
}
        </code>
          </example>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRect">
      <MemberSignature Language="C#" Value="public virtual void DrawRect (System.Drawing.RectangleF area, MonoTouch.UIKit.UIViewPrintFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRect(valuetype System.Drawing.RectangleF area, class MonoTouch.UIKit.UIViewPrintFormatter formatter) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawRect:forViewPrintFormatter:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="area" Type="System.Drawing.RectangleF" />
        <Parameter Name="formatter" Type="MonoTouch.UIKit.UIViewPrintFormatter" />
      </Parameters>
      <Docs>
        <param name="area">The region to be printed</param>
        <param name="formatter">The configured UIViewPrintFormatter,
	which is obtained by accessing the <see cref="P:MonoTouch.UIKit.UIView.PrintFormatter" /> property.</param>
        <summary>Draws a region for printing.</summary>
        <remarks>
          <para>
            UIViews can be printed.  The default behavior is for the contents of
            the UIView as rendered by the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
            method to be printed.
          </para>
          <para>
            You should override the <see cref="M:MonoTouch.UIKit.UIView.DrawRect(System.Drawing.RectangleF,MonoTouch.UIKit.UIView.UIViewPrintFormatter)" />
            method if you want to provide a different implementation
            while printing.
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, MonoTouch.UIKit.UIFont font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIFont font) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
      </Parameters>
      <Docs>
        <param name="str">To be added.</param>
        <param name="point">To be added.</param>
        <param name="font">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="mode" Type="MonoTouch.UIKit.UILineBreakMode" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="mode">The linebreak mode to use to draw the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode breakMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.RectangleF rect, MonoTouch.UIKit.UIFont font, MonoTouch.UIKit.UILineBreakMode mode, MonoTouch.UIKit.UITextAlignment alignment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIFont font, valuetype MonoTouch.UIKit.UILineBreakMode mode, valuetype MonoTouch.UIKit.UITextAlignment alignment) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="mode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="alignment" Type="MonoTouch.UIKit.UITextAlignment" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="rect">Bounding rectangle.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="mode">The linebreak mode to use to draw the string.</param>
        <param name="alignment">The text alignment to use when drawing the string.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float fontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 fontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="fontSize" Type="System.Single" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="fontSize">The font size to use</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Draws the string in the specified rectangle with the specified font.</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float minFontSize, float actualFontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the version with a `ref float actualFontSize`")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="minFontSize" Type="System.Single" />
        <Parameter Name="actualFontSize" Type="System.Single" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="minFontSize">To be added.</param>
        <param name="actualFontSize">
        </param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Obsolete version of this method, use the version with a `ref float actualizeFontSize' parameter instead</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF DrawString (string str, System.Drawing.PointF point, float width, MonoTouch.UIKit.UIFont font, float minFontSize, ref float actualFontSize, MonoTouch.UIKit.UILineBreakMode breakMode, MonoTouch.UIKit.UIBaselineAdjustment adjustment);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF DrawString(string str, valuetype System.Drawing.PointF point, float32 width, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, valuetype MonoTouch.UIKit.UILineBreakMode breakMode, valuetype MonoTouch.UIKit.UIBaselineAdjustment adjustment) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="minFontSize" Type="System.Single" />
        <Parameter Name="actualFontSize" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
        <Parameter Name="adjustment" Type="MonoTouch.UIKit.UIBaselineAdjustment" />
      </Parameters>
      <Docs>
        <param name="str">String to draw.</param>
        <param name="point">The position where the string should be drawn.</param>
        <param name="width">The maximum width to use when drawing.</param>
        <param name="font">Font to use to draw the string.</param>
        <param name="minFontSize">Minimum font size that can be used.</param>
        <param name="actualFontSize">On return, this will contain the font size used.</param>
        <param name="breakMode">The linebreak mode to use to draw the string.</param>
        <param name="adjustment">Baseline adjustment to use.</param>
        <summary>Obsolete version of this method, use the version with a `ref float actualizeFontSize' parameter instead</summary>
        <returns>The actual size used by the rendering.</returns>
        <remarks>
          <para>

	    This drawing routine will try to draw the string at the
	    specified position with the specified width.  If the text
	    does not fit in the specified width, the font sized will
	    be reduced until it reaches the size specified by
	    <paramref name="minFontSize" />.  Any text that does not
	    fit will at that point be truncated according to the
	    <paramref name="breakMode" /> rule.
	    </para>
          <para>This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableInputClicksWhenVisible">
      <MemberSignature Language="C#" Value="public virtual bool EnableInputClicksWhenVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInputClicksWhenVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("enableInputClicksWhenVisible")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeRestorableState">
      <MemberSignature Language="C#" Value="public virtual void EncodeRestorableState (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EncodeRestorableState(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("encodeRestorableStateWithCoder:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndEditing">
      <MemberSignature Language="C#" Value="public bool EndEditing (bool force);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndEditing(bool force) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="force" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="force">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExchangeSubview">
      <MemberSignature Language="C#" Value="public virtual void ExchangeSubview (int atIndex, int withSubviewAtIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExchangeSubview(int32 atIndex, int32 withSubviewAtIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("exchangeSubviewAtIndex:withSubviewAtIndex:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndex" Type="System.Int32" />
        <Parameter Name="withSubviewAtIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="atIndex">
          <para>To be added.</para>
        </param>
        <param name="withSubviewAtIndex">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveTouch">
      <MemberSignature Language="C#" Value="public virtual bool ExclusiveTouch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveTouch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isExclusiveTouch")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setExclusiveTouch:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restricts the event delivery to this view.</summary>
        <value>The default value is false.</value>
        <remarks>
          <para>

	    When this property is set, if this view starts tracking a
	    touch, no other views in the window will receive these
	    events.  Additionally, a view that has set this property
	    to true wont receive any events that are associated with
	    other views in the window.
	  </para>
          <para>

	    If a finger touches a view that hast this property set,
	    the event is only delivered if no other view in the window
	    is tracking a finger.  If a finger touches a non-exclusive
	    window, the event is only delivered if there are no
	    exclusive views tracking a finger.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExerciseAmbiguityInLayout">
      <MemberSignature Language="C#" Value="public virtual void ExerciseAmbiguityInLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExerciseAmbiguityInLayout() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("exerciseAmbiguityInLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Frame">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF Frame { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF Frame" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("frame")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Coordinates of the view relative to its container.</summary>
        <value>The value of this property is in points, not pixels.</value>
        <remarks>
          <para>

	    When changes are done to this property, the <see cref="P:MonoTouch.UIKit.UIView.Center" /> is updated with
	    the new location and the <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> is updated with
	    the new dimensions and a re-layout of the subviews is
	    performed.

	  </para>
          <para>

	    Changing this property will not trigger a call to <see cref="M:MonoTouch.UIKit.UIView.Draw&#xA;     (System.Drawing.RectangleF)" /> unless you set the <see cref="P:MonoTouch.UIKit.UIView.ContentMode" /> property to
	    <see cref="E:MonoTouch.UIKit.UIViewContentMode.Redraw" />.

	  </para>
          <para>

	    At least on iOS 6, changing this property causes the a
	    re-layout of the subviews, even if the dimensions are the
	    same.  This can cause performance problems as some views
	    (like UITableView) can perform some very expensive
	    computations when they are laid out.  

	  </para>
          <para>

	    If your <see cref="P:MonoTouch.UIKit.UIView.ContentMode" />
	    property is set to <see cref="E:MonoTouch.UIKit.UIViewContentMode.Redraw" />, you
	    can avoid a redraw of your view if you update the <see cref="P:MonoTouch.UIKit.UIView.Center" /> property instead
	    of updating the Frame as that one will merely move the
	    view without triggering a call to <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" />.

	  </para>
          <para id="animatable">
	    This property participates in the implicit animation
	    protocol, changing it outside of a transaction will trigger
	    an implicit animation for its values.
	  </para>
          <para>

	    If you change the <see cref="P:MonoTouch.UIKit.UIView.Transform" /> property to a
	    matrix that does not represent the identity matrix,
	    changing this property can have unintended consequences.   In those cases, you should instead update <see cref="P:MonoTouch.UIKit.UIView.Center" /> and <see cref="P:MonoTouch.UIKit.UIView.Bounds" /> directly.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameForAlignmentRect">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF FrameForAlignmentRect (System.Drawing.RectangleF alignmentRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF FrameForAlignmentRect(valuetype System.Drawing.RectangleF alignmentRect) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("frameForAlignmentRect:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignmentRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="alignmentRect">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizers">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIGestureRecognizer[] GestureRecognizers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIGestureRecognizer[] GestureRecognizers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("gestureRecognizers", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setGestureRecognizers:", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIGestureRecognizer[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureRecognizerShouldBegin">
      <MemberSignature Language="C#" Value="public virtual bool GestureRecognizerShouldBegin (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GestureRecognizerShouldBegin(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("gestureRecognizerShouldBegin:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">The gesture recognizer that is
	trying to transitioning out of the <see cref="T:MonoTouch.UIKit.UIGestureRecognizerState" />'s Possible state.</param>
        <summary>Determines if the specified gesture recognizers
	should be allowed to track touch events.</summary>
        <returns>
        </returns>
        <remarks>
	  Override this method if your application handles touches
	  directly, it controls whether an associated
	  <see cref="T:MonoTouch.UIKit.UIGestureRecognizer" /> should execute or not.
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstraintsAffectingLayout">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout (MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.NSLayoutConstraint[] GetConstraintsAffectingLayout(valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("constraintsAffectingLayoutForAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.NSLayoutConstraint[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that lists all of the subviews in this view</summary>
        <returns>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAmbiguousLayout">
      <MemberSignature Language="C#" Value="public virtual bool HasAmbiguousLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAmbiguousLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("hasAmbiguousLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hidden">
      <MemberSignature Language="C#" Value="public virtual bool Hidden { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Hidden" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isHidden")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setHidden:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView HitTest (System.Drawing.PointF point, MonoTouch.UIKit.UIEvent uievent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView HitTest(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIEvent uievent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("hitTest:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="uievent" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>The location to test.</para>
        </param>
        <param name="uievent">
          <para>The event that triggered this call.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>Determines the most nested view that contains the point.</summary>
        <returns>
          <para>The most nested view that contains the point, or null if the point falls outside of the boundaris of the view.</para>
        </returns>
        <remarks>
          <para>

	    This method iterates over all of the visible subviews that
	    have user interaction enabled and that are not entirely
	    transparent to find the most nested view that contains the
	    point.  For each of those views, the method <see cref="M:MonoTouch.UIKit.UIView.PointInside(System.Drawing.PointF,&#xA;     MonoTouch.UIKit.UIEvent)" /> is invoked to determine if
	    there is a match.     

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubview">
      <MemberSignature Language="C#" Value="public virtual void InsertSubview (MonoTouch.UIKit.UIView view, int atIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubview(class MonoTouch.UIKit.UIView view, int32 atIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:atIndex:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="atIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="atIndex">
          <para>The index in the stack of subviews where this view
	will be inserted.</para>
        </param>
        <summary>Inserts the specified subview at the specified
	location as a subview of this view.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewAbove">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewAbove (MonoTouch.UIKit.UIView view, MonoTouch.UIKit.UIView siblingSubview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewAbove(class MonoTouch.UIKit.UIView view, class MonoTouch.UIKit.UIView siblingSubview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:aboveSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="siblingSubview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view above the siblingSubvie in
	the view hierarchy</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSubviewBelow">
      <MemberSignature Language="C#" Value="public virtual void InsertSubviewBelow (MonoTouch.UIKit.UIView view, MonoTouch.UIKit.UIView siblingSubview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSubviewBelow(class MonoTouch.UIKit.UIView view, class MonoTouch.UIKit.UIView siblingSubview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSubview:belowSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="siblingSubview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>The view to add as a nested view of this view.</para>
        </param>
        <param name="siblingSubview">
          <para>The subview of this view that will be below the view.</para>
        </param>
        <summary>Inserts the specified view below the siblingSubvie in
	the view hierarchy.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF IntrinsicContentSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF IntrinsicContentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("intrinsicContentSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateIntrinsicContentSize">
      <MemberSignature Language="C#" Value="public virtual void InvalidateIntrinsicContentSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InvalidateIntrinsicContentSize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("invalidateIntrinsicContentSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOfView">
      <MemberSignature Language="C#" Value="public virtual bool IsDescendantOfView (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDescendantOfView(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("isDescendantOfView:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Layer">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreAnimation.CALayer Layer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.CoreAnimation.CALayer Layer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("layer", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreAnimation.CALayer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>(More documentation for this node is coming)</para>
          <para tool="threads">This can be used from a background thread.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void LayoutIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutIfNeeded() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("layoutIfNeeded")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out the subviews if needed.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutSubviews">
      <MemberSignature Language="C#" Value="public virtual void LayoutSubviews ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LayoutSubviews() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("layoutSubviews")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lays out subviews.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToSuperview">
      <MemberSignature Language="C#" Value="public virtual void MovedToSuperview ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToSuperview() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didMoveToSuperview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MovedToWindow">
      <MemberSignature Language="C#" Value="public virtual void MovedToWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MovedToWindow() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didMoveToWindow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MultipleTouchEnabled">
      <MemberSignature Language="C#" Value="public virtual bool MultipleTouchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MultipleTouchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isMultipleTouchEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setMultipleTouchEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controls whether the UIView can handle multitouch events.</summary>
        <value>State of multiple touch recotgnition.</value>
        <remarks>
	  UIViews by default only handle a single touch event at once.  If you
	  want your view to handle multiple touches, you must set this property
	  to true.
	</remarks>
      </Docs>
    </Member>
    <Member MemberName="NeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual bool NeedsUpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool NeedsUpdateConstraints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("needsUpdateConstraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NoIntrinsicMetric">
      <MemberSignature Language="C#" Value="public static float NoIntrinsicMetric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float32 NoIntrinsicMetric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UIViewNoIntrinsicMetric</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opaque">
      <MemberSignature Language="C#" Value="public virtual bool Opaque { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Opaque" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isOpaque")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setOpaque:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the view is opaque or not.</summary>
        <value>
        </value>
        <remarks>
          <para>

	    If you set this value to true, you should make sure that
	    the entire area is painted, if you do not, the behavior is
	    undefined.  You should also set the <see cref="T:MonoTouch.UIKit.UIView.Alpha" /> property to 1.0.

	  </para>
          <para>
	    Whenever possible, you should try to set the view as
	    opaque, as that informs UIKit that the view does not need
	    to be composited and blended with underlying views.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointInside">
      <MemberSignature Language="C#" Value="public virtual bool PointInside (System.Drawing.PointF point, MonoTouch.UIKit.UIEvent uievent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PointInside(valuetype System.Drawing.PointF point, class MonoTouch.UIKit.UIEvent uievent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("pointInside:withEvent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="uievent" Type="MonoTouch.UIKit.UIEvent" />
      </Parameters>
      <Docs>
        <param name="point">
          <para>To be added.</para>
        </param>
        <param name="uievent">
          <para>
          </para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraint">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraint (MonoTouch.UIKit.NSLayoutConstraint constraint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraint(class MonoTouch.UIKit.NSLayoutConstraint constraint) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeConstraint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="MonoTouch.UIKit.NSLayoutConstraint" />
      </Parameters>
      <Docs>
        <param name="constraint">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveConstraints">
      <MemberSignature Language="C#" Value="public virtual void RemoveConstraints (MonoTouch.UIKit.NSLayoutConstraint[] constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveConstraints(class MonoTouch.UIKit.NSLayoutConstraint[] constraints) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeConstraints:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraints" Type="MonoTouch.UIKit.NSLayoutConstraint[]" />
      </Parameters>
      <Docs>
        <param name="constraints">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSuperview">
      <MemberSignature Language="C#" Value="public virtual void RemoveFromSuperview ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFromSuperview() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeFromSuperview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGestureRecognizer">
      <MemberSignature Language="C#" Value="public virtual void RemoveGestureRecognizer (MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveGestureRecognizer(class MonoTouch.UIKit.UIGestureRecognizer gestureRecognizer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeGestureRecognizer:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gestureRecognizer" Type="MonoTouch.UIKit.UIGestureRecognizer" />
      </Parameters>
      <Docs>
        <param name="gestureRecognizer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiresConstraintBasedLayout">
      <MemberSignature Language="C#" Value="public static bool RequiresConstraintBasedLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RequiresConstraintBasedLayout() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("requiresConstraintBasedLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestorationIdentifier">
      <MemberSignature Language="C#" Value="public virtual string RestorationIdentifier { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RestorationIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("restorationIdentifier")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setRestorationIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendSubviewToBack">
      <MemberSignature Language="C#" Value="public virtual void SendSubviewToBack (MonoTouch.UIKit.UIView view);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SendSubviewToBack(class MonoTouch.UIKit.UIView view) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sendSubviewToBack:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="view">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationBeginsFromCurrentState">
      <MemberSignature Language="C#" Value="public static void SetAnimationBeginsFromCurrentState (bool fromCurrentState);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationBeginsFromCurrentState(bool fromCurrentState) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationBeginsFromCurrentState:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromCurrentState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fromCurrentState">true if you want to start the
      animation from the current state, false otherwise.</param>
        <summary>Sets whether the animation transaction will animate
      from the current view state.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationCurve">
      <MemberSignature Language="C#" Value="public static void SetAnimationCurve (MonoTouch.UIKit.UIViewAnimationCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationCurve(valuetype MonoTouch.UIKit.UIViewAnimationCurve curve) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationCurve:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="MonoTouch.UIKit.UIViewAnimationCurve" />
      </Parameters>
      <Docs>
        <param name="curve">Curve used to animate the property changes.</param>
        <summary>Sets the animation curve for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelay">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelay (double delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelay(float64 delay) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDelay:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="delay">Delay in seconds.</param>
        <summary>Sets the animation delay for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDelegate">
      <MemberSignature Language="C#" Value="public static void SetAnimationDelegate (MonoTouch.Foundation.NSObject del);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDelegate(class MonoTouch.Foundation.NSObject del) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="del" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="del">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDidStopSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationDidStopSelector (MonoTouch.ObjCRuntime.Selector sel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDidStopSelector(class MonoTouch.ObjCRuntime.Selector sel) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDidStopSelector:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="MonoTouch.ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="sel">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationDuration">
      <MemberSignature Language="C#" Value="public static void SetAnimationDuration (double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationDuration(float64 duration) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationDuration:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="duration">Duration in seconds.</param>
        <summary>Sets the duration for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatAutoreverses">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatAutoreverses (bool repeatAutoreverses);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatAutoreverses(bool repeatAutoreverses) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationRepeatAutoreverses:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatAutoreverses" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="repeatAutoreverses">True if this animation should autoreverse when it completes.</param>
        <summary>Sets whether this animation transaction will automatically reverse when it completes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationRepeatCount">
      <MemberSignature Language="C#" Value="public static void SetAnimationRepeatCount (float repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationRepeatCount(float32 repeatCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationRepeatCount:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="repeatCount" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="repeatCount">Count</param>
        <summary>Sets the repeat count for this animation transaction.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationStartDate">
      <MemberSignature Language="C#" Value="public static void SetAnimationStartDate (MonoTouch.Foundation.NSDate startDate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationStartDate(class MonoTouch.Foundation.NSDate startDate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationStartDate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startDate" Type="MonoTouch.Foundation.NSDate" />
      </Parameters>
      <Docs>
        <param name="startDate">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationTransition">
      <MemberSignature Language="C#" Value="public static void SetAnimationTransition (MonoTouch.UIKit.UIViewAnimationTransition transition, MonoTouch.UIKit.UIView forView, bool cache);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationTransition(valuetype MonoTouch.UIKit.UIViewAnimationTransition transition, class MonoTouch.UIKit.UIView forView, bool cache) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationTransition:forView:cache:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transition" Type="MonoTouch.UIKit.UIViewAnimationTransition" />
        <Parameter Name="forView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="cache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="transition">To be added.</param>
        <param name="forView">To be added.</param>
        <param name="cache">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAnimationWillStartSelector">
      <MemberSignature Language="C#" Value="public static void SetAnimationWillStartSelector (MonoTouch.ObjCRuntime.Selector sel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAnimationWillStartSelector(class MonoTouch.ObjCRuntime.Selector sel) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setAnimationWillStartSelector:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sel" Type="MonoTouch.ObjCRuntime.Selector" />
      </Parameters>
      <Docs>
        <param name="sel">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContentCompressionResistancePriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentCompressionResistancePriority (float priority, MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentCompressionResistancePriority(float32 priority, valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setContentCompressionResistancePriority:forAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single" />
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="priority">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContentHuggingPriority">
      <MemberSignature Language="C#" Value="public virtual void SetContentHuggingPriority (float priority, MonoTouch.UIKit.UILayoutConstraintAxis axis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentHuggingPriority(float32 priority, valuetype MonoTouch.UIKit.UILayoutConstraintAxis axis) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setContentHuggingPriority:forAxis:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Single" />
        <Parameter Name="axis" Type="MonoTouch.UIKit.UILayoutConstraintAxis" />
      </Parameters>
      <Docs>
        <param name="priority">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplay">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplay ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplay() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsDisplay")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marks the view dirty and queues a redraw operation on it.</summary>
        <remarks>
          <para>
	    This method is invoked if the contents of the view need to
	    be refreshed due to a change of state or geometry.  Invoking
	    this method will cause the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
	    method to be invoked.
	  </para>
          <para>
	    Alternatively you can use the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplayInRect(System.Drawing.RectangleF)" />
	    method to only mark a specific region of the view to be repainted.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsDisplayInRect">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsDisplayInRect (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsDisplayInRect(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsDisplayInRect:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">
          <para>The region that will be marked as dirty.</para>
        </param>
        <summary>Marks a region of the view as dirty and queues a redraw operation on that region.</summary>
        <remarks>
          <para>
	    This method is invoked if a region of the contents of the view need to
	    be refreshed due to a change of state or geometry.  Invoking
	    this method will cause the <see cref="M:MonoTouch.UIKit.UIView.Draw(System.Drawing.RectangleF)" />
	    method to be invoked.
	  </para>
          <para>
	    Alternatively you can use the <see cref="M:MonoTouch.UIKit.UIView.SetNeedsDisplay()" />
	    method if you want to repaing the entire view.
	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsLayout">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsLayout() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets whether subviews need to be rearranged before displaying.</summary>
        <remarks>
	  If the state of your view changes in response to some API calls,
	  instead of changing the layout manually in response to the change,
	  you should invoke this method which will
	  flag the view for a layout.  The layout event will then be processed
	  the next time the main loop runs.  By using this approach, you can
	  coalesce multiple changes to the layout in a single pass.
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetNeedsUpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void SetNeedsUpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetNeedsUpdateConstraints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setNeedsUpdateConstraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeThatFits">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF SizeThatFits (System.Drawing.SizeF size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.SizeF SizeThatFits(valuetype System.Drawing.SizeF size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sizeThatFits:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="size">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToFit">
      <MemberSignature Language="C#" Value="public virtual void SizeToFit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SizeToFit() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("sizeToFit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
      </Parameters>
      <Docs>
        <param name="str">To be added.</param>
        <param name="font">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, System.Drawing.SizeF constrainedToSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.Drawing.SizeF constrainedToSize) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="constrainedToSize" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="str">To be added.</param>
        <param name="font">To be added.</param>
        <param name="constrainedToSize">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, System.Drawing.SizeF constrainedToSize, MonoTouch.UIKit.UILineBreakMode lineBreakMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, valuetype System.Drawing.SizeF constrainedToSize, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="constrainedToSize" Type="System.Drawing.SizeF" />
        <Parameter Name="lineBreakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
      </Parameters>
      <Docs>
        <param name="str">To be added.</param>
        <param name="font">To be added.</param>
        <param name="constrainedToSize">To be added.</param>
        <param name="lineBreakMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, float forWidth, MonoTouch.UIKit.UILineBreakMode breakMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, float32 forWidth, valuetype MonoTouch.UIKit.UILineBreakMode breakMode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="forWidth" Type="System.Single" />
        <Parameter Name="breakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
      </Parameters>
      <Docs>
        <param name="str">To be added.</param>
        <param name="font">To be added.</param>
        <param name="forWidth">To be added.</param>
        <param name="breakMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringSize">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF StringSize (string str, MonoTouch.UIKit.UIFont font, float minFontSize, ref float actualFontSize, float forWidth, MonoTouch.UIKit.UILineBreakMode lineBreakMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF StringSize(string str, class MonoTouch.UIKit.UIFont font, float32 minFontSize, float32 actualFontSize, float32 forWidth, valuetype MonoTouch.UIKit.UILineBreakMode lineBreakMode) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.ThreadSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="font" Type="MonoTouch.UIKit.UIFont" />
        <Parameter Name="minFontSize" Type="System.Single" />
        <Parameter Name="actualFontSize" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="forWidth" Type="System.Single" />
        <Parameter Name="lineBreakMode" Type="MonoTouch.UIKit.UILineBreakMode" />
      </Parameters>
      <Docs>
        <param name="str">To be added.</param>
        <param name="font">To be added.</param>
        <param name="minFontSize">To be added.</param>
        <param name="actualFontSize">To be added.</param>
        <param name="forWidth">To be added.</param>
        <param name="lineBreakMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubviewAdded">
      <MemberSignature Language="C#" Value="public virtual void SubviewAdded (MonoTouch.UIKit.UIView uiview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SubviewAdded(class MonoTouch.UIKit.UIView uiview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("didAddSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The view that was added as a subview.</para>
        </param>
        <summary>Tells the view when subviews are added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subviews">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView[] Subviews { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView[] Subviews" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("subviews", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Superview">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView Superview { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView Superview" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("superview")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemLayoutSizeFittingSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF SystemLayoutSizeFittingSize (System.Drawing.SizeF size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.SizeF SystemLayoutSizeFittingSize(valuetype System.Drawing.SizeF size) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("systemLayoutSizeFittingSize:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="size">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public virtual int Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tag")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTag:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGAffineTransform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.CoreGraphics.CGAffineTransform Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("transform")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTransform:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreGraphics.CGAffineTransform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="fromView">To be added.</param>
        <param name="toView">To be added.</param>
        <param name="duration">To be added.</param>
        <param name="options">To be added.</param>
        <param name="completion">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transition">
      <MemberSignature Language="C#" Value="public static void Transition (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.Foundation.NSAction completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Transition(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.Foundation.NSAction completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.Foundation.NSAction" />
      </Parameters>
      <Docs>
        <param name="withView">To be added.</param>
        <param name="duration">To be added.</param>
        <param name="options">To be added.</param>
        <param name="animation">To be added.</param>
        <param name="completion">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (MonoTouch.UIKit.UIView fromView, MonoTouch.UIKit.UIView toView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class MonoTouch.UIKit.UIView fromView, class MonoTouch.UIKit.UIView toView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("transitionFromView:toView:duration:options:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="toView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler" />
      </Parameters>
      <Docs>
        <param name="fromView">To be added.</param>
        <param name="toView">To be added.</param>
        <param name="duration">To be added.</param>
        <param name="options">To be added.</param>
        <param name="completion">
          <para>The method to invoke when the transition completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransitionNotify">
      <MemberSignature Language="C#" Value="public static void TransitionNotify (MonoTouch.UIKit.UIView withView, double duration, MonoTouch.UIKit.UIViewAnimationOptions options, MonoTouch.Foundation.NSAction animation, MonoTouch.UIKit.UICompletionHandler completion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TransitionNotify(class MonoTouch.UIKit.UIView withView, float64 duration, valuetype MonoTouch.UIKit.UIViewAnimationOptions options, class MonoTouch.Foundation.NSAction animation, class MonoTouch.UIKit.UICompletionHandler completion) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("transitionWithView:duration:options:animations:completion:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="withView" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="duration" Type="System.Double" />
        <Parameter Name="options" Type="MonoTouch.UIKit.UIViewAnimationOptions" />
        <Parameter Name="animation" Type="MonoTouch.Foundation.NSAction" />
        <Parameter Name="completion" Type="MonoTouch.UIKit.UICompletionHandler" />
      </Parameters>
      <Docs>
        <param name="withView">To be added.</param>
        <param name="duration">To be added.</param>
        <param name="options">To be added.</param>
        <param name="animation">To be added.</param>
        <param name="completion">
          <para>The method to invoke when the transition completes.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatesAutoresizingMaskIntoConstraints">
      <MemberSignature Language="C#" Value="public virtual bool TranslatesAutoresizingMaskIntoConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TranslatesAutoresizingMaskIntoConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("translatesAutoresizingMaskIntoConstraints")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTranslatesAutoresizingMaskIntoConstraints:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingCompressedSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF UILayoutFittingCompressedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.SizeF UILayoutFittingCompressedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingCompressedSize</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UILayoutFittingExpandedSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF UILayoutFittingExpandedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.SizeF UILayoutFittingExpandedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the value associated with the constant UILayoutFittingExpandedSize</summary>
        <value>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraints">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraints() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateConstraints")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateConstraintsIfNeeded">
      <MemberSignature Language="C#" Value="public virtual void UpdateConstraintsIfNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateConstraintsIfNeeded() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateConstraintsIfNeeded")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInteractionEnabled">
      <MemberSignature Language="C#" Value="public virtual bool UserInteractionEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserInteractionEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isUserInteractionEnabled")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setUserInteractionEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether input events are processed by this view.</summary>
        <value>
        </value>
        <remarks>
          <para>

	    This property is used to control whether input events are
	    delivered to the view.  By default all views receive
	    events.  

	  </para>
          <para>

	    During animations, UIKit will disable event delivery to
	    your view unless you pass the <see cref="E:MonoTouch.UIKit.UIViewAnimationOptions" />.AllowUserInteraction
	    flag to your animation function.

	  </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewForBaselineLayout">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ViewForBaselineLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView ViewForBaselineLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("viewForBaselineLayout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewPrintFormatter">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewPrintFormatter ViewPrintFormatter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIViewPrintFormatter ViewPrintFormatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(4, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("viewPrintFormatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewPrintFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewWithTag">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView ViewWithTag (int tag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIView ViewWithTag(int32 tag) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("viewWithTag:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tag" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tag">
          <para>To be added.</para>
        </param>
        <summary>To be added.</summary>
        <returns>
          <para>To be added.</para>
        </returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillMoveToSuperview">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToSuperview (MonoTouch.UIKit.UIView newsuper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToSuperview(class MonoTouch.UIKit.UIView newsuper) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willMoveToSuperview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newsuper" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="newsuper">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillMoveToWindow">
      <MemberSignature Language="C#" Value="public virtual void WillMoveToWindow (MonoTouch.UIKit.UIWindow window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillMoveToWindow(class MonoTouch.UIKit.UIWindow window) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willMoveToWindow:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="MonoTouch.UIKit.UIWindow" />
      </Parameters>
      <Docs>
        <param name="window">
          <para>To be added.</para>
          <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WillRemoveSubview">
      <MemberSignature Language="C#" Value="public virtual void WillRemoveSubview (MonoTouch.UIKit.UIView uiview);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WillRemoveSubview(class MonoTouch.UIKit.UIView uiview) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("willRemoveSubview:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uiview" Type="MonoTouch.UIKit.UIView" />
      </Parameters>
      <Docs>
        <param name="uiview">
          <para>The subview that will be removed.</para>
        </param>
        <summary>To be added.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIWindow Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("window")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
