<Type Name="UIImage" FullName="MonoTouch.UIKit.UIImage">
  <TypeSignature Language="C#" Value="public class UIImage : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIImage extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIImage", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Image representation in UIKit, with support for loading, saving and manipulating images.</summary>
    <remarks>
      <para>A UIImage object is a high-level way to display image data. You can create images from files, from Quartz image objects, or from raw image data you receive. The UIImage class also offers several options for drawing images to the current graphics context using different blend modes and opacity values.</para>
      <para>Image objects are immutable, so you cannot change their properties after creation. This means that you generally specify an image’s properties at initialization time or rely on the image’s metadata to provide the property value. In some cases, however, the UIImage class provides convenience methods for obtaining a copy of the image that uses custom values for a property.</para>
      <para>Because image objects are immutable, they also do not provide direct access to their underlying image data. However, you can get an <see cref="T:MonoTouch.Foundation.NSObject.NSData" /> object containing either a PNG or JPEG representation of the image data using the UIImagePNGRepresentation and UIImageJPEGRepresentation functions.</para>
      <para>The system uses image objects to represent still pictures taken with the camera on supported devices. To take a picture, use the UIImagePickerController class. To save a picture to the Saved Photos album, use the UIImageWriteToSavedPhotosAlbum function.</para>
      <para>Images and Memory Management</para>
      <para>In low-memory situations, image data may be purged from a UIImage object to free up memory on the system. This purging behavior affects only the image data stored internally by the UIImage object and not the object itself. When you attempt to draw an image whose data has been purged, the image object automatically reloads the data from its original file. This extra load step, however, may incur a small performance penalty.</para>
      <para>You should avoid creating UIImage objects that are greater than 1024 x 1024 in size. Besides the large amount of memory such an image would consume, you may run into problems when using the image as a texture in OpenGL ES or when drawing the image to a view or layer. This size restriction does not apply if you are performing code-based manipulations, such as resizing an image larger than 1024 x 1024 pixels by drawing it to a bitmap-backed graphics context. In fact, you may need to resize an image in this manner (or break it into several smaller images) in order to draw it to one of your views.</para>
      <para>Supported Image Formats</para>
      <para>The following table lists the file formats that can be read by the UIImage class: <br/>
        <list type="table">
          <item>
            <term>Tagged Image File Format (TIFF)</term>
            <description>.tiff, .tif</description>
          </item> 
          <item>
            <term>Joint Photographic Experts Group (JPEG)</term> 
            <description>.jpg, .jpeg</description>
          </item>
          <item>
            <term>Graphics Interchange Format (GIF)</term>
            <description>.gif</description>
          <item>
          <item>
            <term>Portable Network Graphic (PNG)</term>
            <description>.png</description>
          </item>
          <item>
            <term>Windows Bitmap Format (DIB)</term>
            <description>.bmp, .BMPf</description>
          </item>
          <item>
            <term>Windows Icon Format</term>
            <description>.ico</description>
          </item>
          <item>
            <term>Windows Cursor</term>
            <description>.cur</description>
          </item>
          <item>
            <term>XWindow bitmap</term>
            <description>.xbm</description>
          </item>
          </item>
        </list>
        <listheader>
          <term>Format</term>
          <description>Filename extensions</description>
        </listheader>
      </para>
      <para>Note: Windows Bitmap Format files that are formatted as RGB-565 are converted to ARGB-1555 when they are loaded.
    </remarks>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=064a9ab4-1e58-4cf6-a1c2-aab04997aa57">Example_Drawing</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=6b7f700b-aad2-4d67-a437-3a3482728a1b">Example_Touch</related>
    <related type="recipe" href="http://docs.xamarin.com/ios/Recipes/Media/Images/Merge_Images">Merge Images</related>
    <related type="recipe" href="http://docs.xamarin.com/ios/Recipes/Media/Images/Rotate_An_Image">Rotate An Image</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.CoreGraphics.CGImage cgImage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.CoreGraphics.CGImage cgImage) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCGImage:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="cgImage" Type="MonoTouch.CoreGraphics.CGImage" />
      </Parameters>
      <Docs>
        <param name="cgImage">A Quartz image reference.</param>
        <summary>Initializes with the specified Quartz image reference.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.CoreImage.CIImage ciImage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.CoreImage.CIImage ciImage) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCIImage")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="ciImage" Type="MonoTouch.CoreImage.CIImage" />
      </Parameters>
      <Docs>
        <param name="ciImage">The Core image object.</param>
        <summary>Initializes with the specified Core Image object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.Foundation.NSData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSData data) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithData:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advatnage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsability to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.UIKit.UIImage image);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.UIKit.UIImage image) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithImage:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="image" Type="MonoTouch.UIKit.UIImage" />
      </Parameters>
      <Docs>
        <param name="image">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithContentsOfFile:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The path to the file. This path should include the filename extension that identifies the type of the image data.</param>
        <summary>Initializes with the contents of the specified file.</summary>
        <remarks>This method loads the image data into memory and marks it as purgeable. If the data is purged and needs to be reloaded, the image object loads that data again from the specified path.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.UIKit.UIImage image, MonoTouch.Foundation.NSDictionary options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.UIKit.UIImage image, class MonoTouch.Foundation.NSDictionary options) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithImage:options:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="image" Type="MonoTouch.UIKit.UIImage" />
        <Parameter Name="options" Type="MonoTouch.Foundation.NSDictionary" />
      </Parameters>
      <Docs>
        <param name="image">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIImage (MonoTouch.CoreGraphics.CGImage cgImage, float scale, MonoTouch.UIKit.UIImageOrientation orientation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.CoreGraphics.CGImage cgImage, float32 scale, valuetype MonoTouch.UIKit.UIImageOrientation orientation) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCGImage:scale:orientation:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="cgImage" Type="MonoTouch.CoreGraphics.CGImage" />
        <Parameter Name="scale" Type="System.Single" />
        <Parameter Name="orientation" Type="MonoTouch.UIKit.UIImageOrientation" />
      </Parameters>
      <Docs>
        <param name="cgImage">The Quartz image object.</param>
        <param name="scale">The scale factor to assume when interpreting the image data. Applying a scale factor of 1.0 results in an image whose size matches the pixel-based dimensions of the image. Applying a different scale factor changes the size of the image as reported by the size property.</param>
        <param name="orientation">The orientation of the image data. You can use this parameter to specify any rotation factors applied to the image.</param>
        <summary>Initializes with the specified scale and orientation factors</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsJPEG">
      <MemberSignature Language="C#" Value="public MonoTouch.Foundation.NSData AsJPEG ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.Foundation.NSData AsJPEG() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encodes the image with minimal compression (maximum quality) into a <see cref="T:MonoTouch.Foundation.NSData" /> byte blob using the JPEG encoding.</summary>
        <returns>The encoded image in an NSData wrapper or null if there was an error.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsJPEG">
      <MemberSignature Language="C#" Value="public MonoTouch.Foundation.NSData AsJPEG (float compressionQuality);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.Foundation.NSData AsJPEG(float32 compressionQuality) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compressionQuality" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="compressionQuality">The compression quality to use, 0.0 is the maximum compression (worse quality), and 1.0 minimum compression (best quality)</param>
        <summary>Encodes the image into a <see cref="T:MonoTouch.Foundation.NSData" /> byte blob using the JPEG encoding.</summary>
        <returns>The encoded image in an NSData wrapper or null if there was an error.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsPNG">
      <MemberSignature Language="C#" Value="public MonoTouch.Foundation.NSData AsPNG ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.Foundation.NSData AsPNG() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encodes the image into a <see cref="T:MonoTouch.Foundation.NSData" /> byte blob using the PNG encoding.</summary>
        <returns>The encoded image in an NSData wrapper or null if there was an error.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CapInsets">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIEdgeInsets CapInsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIEdgeInsets CapInsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("capInsets")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The end-cap insets. (read-only)</summary>
        <value>To be added.</value>
        <remarks>
          <para>End caps specify the portion of an image that should not be resized when an image is stretched. This technique is used to implement buttons and other resizable image-based interface elements. When a button with end caps is resized, the resizing occurs only in the middle of the bottom, in the region between the end caps. The end caps themselves keep their original size and appearance.</para>
          <para>This property specifies the sizes of all four end caps. The middle (stretchable) portion consists of all the pixels that are not included in the end caps. These pixels are tiled, left-to-right, top-to-bottom to fill the remaining space.</para>
          <para>On a non-resizeable image, this property is set to UIEdgeInsetsZero; the image does not use end caps and the entire image is subject to stretching. To create a new image with a nonzero value for this property, use the resizableImageWithCapInsets: method. If your application specifies UIEdgeInsetsZero as the capInsets parameter, the entire image is tiled.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CGImage">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreGraphics.CGImage CGImage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.CoreGraphics.CGImage CGImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("CGImage")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreGraphics.CGImage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>They underlying Quartz image data. (read-only)</summary>
        <value>To be added.</value>
        <remarks>
          <para>If the image data has been purged because of memory constraints, invoking this method forces that data to be loaded back into memory. Reloading the image data may incur a performance penalty.</para>
          <para>If the UIImage object was initialized using a CIImage object, the value of the property is NULL.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CIImage">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.CoreImage.CIImage CIImage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.CoreImage.CIImage CIImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("CIImage")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreImage.CIImage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The underlying Core Image data. (read-only)</summary>
        <value>To be added.</value>
        <remarks><para>If the UIImage object was initialized using a CGImageRef, the value of the property is nil.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAnimatedImage">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage CreateAnimatedImage (MonoTouch.UIKit.UIImage[] images, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage CreateAnimatedImage(class MonoTouch.UIKit.UIImage[] images, float64 duration) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animatedImageWithImages:duration:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="images" Type="MonoTouch.UIKit.UIImage[]" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="images">An array of UIImage objects.</param>
        <param name="duration">The duration of the animation.</param>
        <summary>Creates and returns an animated image.</summary>
        <returns>A new image object.</returns>
        <remarks>All images included in the animated image should share the same size and scale.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAnimatedImage">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage CreateAnimatedImage (string name, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage CreateAnimatedImage(string name, float64 duration) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animatedImageNamed:duration:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="name">The full or partial path to the file (sans suffix).</param>
        <param name="duration">The duration of the animation.</param>
        <summary>Creates and returns an animated image.</summary>
        <returns>A new image object.</returns>
        <remarks><para>This method loads a series of files by appending a series of numbers to the base file name provided in the name parameter. For example, if the name parameter had ‘image’ as its contents, this method would attempt to load images from files with the names ‘image0’, ‘image1’ and so on all the way up to ‘image1024’. All images included in the animated image should share the same size and scale.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAnimatedImage">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage CreateAnimatedImage (MonoTouch.UIKit.UIImage[] images, MonoTouch.UIKit.UIEdgeInsets capInsets, double duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage CreateAnimatedImage(class MonoTouch.UIKit.UIImage[] images, valuetype MonoTouch.UIKit.UIEdgeInsets capInsets, float64 duration) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("animatedResizableImageNamed:capInsets:duration:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="images" Type="MonoTouch.UIKit.UIImage[]" />
        <Parameter Name="capInsets" Type="MonoTouch.UIKit.UIEdgeInsets" />
        <Parameter Name="duration" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="images">To be added.</param>
        <param name="capInsets">The values to use for the cap insets.</param>
        <param name="duration">The duration of the animation.</param>
        <summary>Creates and returns an animated image with end caps.</summary>
        <returns>A new image object.</returns>
        <remarks><para>This method loads a series of files by appending a series of numbers to the base file name provided in the name parameter. For example, if the name parameter had ‘image’ as its contents, this method would attempt to load images from files with the names ‘image0’, ‘image1’ and so on all the way up to ‘image1024’. All images included in the animated image should share the same size and scale.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateResizableImage">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIImage CreateResizableImage (MonoTouch.UIKit.UIEdgeInsets capInsets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIImage CreateResizableImage(valuetype MonoTouch.UIKit.UIEdgeInsets capInsets) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("resizableImageWithCapInsets:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capInsets" Type="MonoTouch.UIKit.UIEdgeInsets" />
      </Parameters>
      <Docs>
        <param name="capInsets">The values to use for the cap insets.</param>
        <summary>Creates and returns a new image object with the specified cap insets.</summary>
        <returns>A new image object with the specified cap insets.</returns>
        <remarks><para>You use this method to add cap insets to an image or to change the existing cap insets of an image. In both cases, you get back a new image and the original image remains untouched.</para>
        <para>During scaling or resizing of the image, areas covered by a cap are not scaled or resized. Instead, the pixel area not covered by the cap in each direction is tiled, left-to-right and top-to-bottom, to resize the image. This technique is often used to create variable-width buttons, which retain the same rounded corners but whose center region grows or shrinks as needed. For best performance, use a tiled area that is a 1x1 pixel area in size.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentScale">
      <MemberSignature Language="C#" Value="public virtual float CurrentScale { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 CurrentScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("scale")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The scale factor of the image. (read-only)</summary>
        <value>To be added.</value>
        <remarks>
          <para>If you load an image from a file whose name includes the @2x modifier, the scale is set to 2.0. If the filename does not include the modifier but is in the PNG or JPEG format and has an associated DPI value, a corresponding scale factor is computed and reflected in this property. You can also specify an explicit scale factor when initializing an image from a Core Graphics image. All other images are assumed to have a scale factor of 1.0.</para>
          <para>If you multiply the logical size of the image (stored in the size property) by the value in this property, you get the dimensions of the image in pixels.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resourced used by the UIImage object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIImage class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposting <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UIImage ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype System.Drawing.PointF point) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawAtPoint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">The point at which to draw the top-left corner of the image.</param>
        <summary>Draws the image at the specified point in the current context.</summary>
        <remarks><para>This method draws the entire image in the current graphics context, respecting the image’s orientation setting. In the default coordinate system, images are situated down and to the right of the specified point. This method respects any transforms applied to the current graphics context, however.</para>
        <para>This method draws the image at full opacity using the kCGBlendModeNormal blend mode.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawInRect:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">The rectangle (in the coordinate system of the graphics context) in which to draw the image.</param>
        <summary>Draws the entire image in the specified rectangle, scaling it as needed to fit.</summary>
        <remarks><para>This method draws the entire image in the current graphics context, respecting the image’s orientation setting. In the default coordinate system, images are situated down and to the right of the origin of the specified rectangle. This method respects any transforms applied to the current graphics context, however.</para>
        <para>This method draws the image at full opacity using the kCGBlendModeNormal blend mode.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (System.Drawing.PointF point, MonoTouch.CoreGraphics.CGBlendMode blendMode, float alpha);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype System.Drawing.PointF point, valuetype MonoTouch.CoreGraphics.CGBlendMode blendMode, float32 alpha) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawAtPoint:blendMode:alpha:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="blendMode" Type="MonoTouch.CoreGraphics.CGBlendMode" />
        <Parameter Name="alpha" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="point">The point at which to draw the top-left corner of the image.</param>
        <param name="blendMode">The blend mode to use when compositing the image.</param>
        <param name="alpha">The desired opacity of the image, specified as a value between 0.0 and 1.0. A value of 0.0 renders the image totally transparent while 1.0 renders it fully opaque. Values larger than 1.0 are interpreted as 1.0.</param>
        <summary>Draws the entire image at the specified point using the custom compositing options.</summary>
        <remarks>This method draws the entire image in the current graphics context, respecting the image’s orientation setting. In the default coordinate system, images are situated down and to the right of the specified point. This method respects any transforms applied to the current graphics context, however.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public virtual void Draw (System.Drawing.RectangleF rect, MonoTouch.CoreGraphics.CGBlendMode blendMode, float alpha);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Draw(valuetype System.Drawing.RectangleF rect, valuetype MonoTouch.CoreGraphics.CGBlendMode blendMode, float32 alpha) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawInRect:blendMode:alpha:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="blendMode" Type="MonoTouch.CoreGraphics.CGBlendMode" />
        <Parameter Name="alpha" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">The rectangle (in the coordinate system of the graphics context) in which to draw the image.</param>
        <param name="blendMode">The blend mode to use when compositing the image.</param>
        <param name="alpha">The desired opacity of the image, specified as a value between 0.0 and 1.0. A value of 0.0 renders the image totally transparent while 1.0 renders it fully opaque. Values larger than 1.0 are interpreted as 1.0.</param>
        <summary>Draws the entire image in the specified rectangle and using the specified compositing options.</summary>
        <remarks>This method scales the image as needed to make it fit in the specified rectangle. This method draws the image in the current graphics context, respecting the image’s orientation setting. In the default coordinate system, images are situated down and to the right of the origin of the specified rectangle. This method respects any transforms applied to the current graphics context, however.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawAsPatternInRect">
      <MemberSignature Language="C#" Value="public virtual void DrawAsPatternInRect (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawAsPatternInRect(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("drawAsPatternInRect:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">The rectangle (in the coordinate system of the graphics context) in which to draw the image.</param>
        <summary>Draws a tiled Quartz pattern using the receiver's contents as the tile pattern.</summary>
        <remarks><para>This method uses a Quartz pattern to tile the image in the specified rectangle. The image is tiled with no gaps and the fill color is ignored. In the default coordinate system, the image tiles are situated down and to the right of the origin of the specified rectangle. This method respects any transforms applied to the current graphics context, however.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Duration">
      <MemberSignature Language="C#" Value="public virtual double Duration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Duration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("duration")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the time interval used to display an animated image. (read-only)</summary>
        <value>To be added.</value>
        <remarks><para>For a non-animated image, the value of this property is 0.0.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBundle">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage FromBundle (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage FromBundle(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("imageNamed:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Loads an image from the bundle with the specified path name.</param>
        <summary>Loads an image relative to the application bundle, and caches its result.</summary>
        <returns>The image object for the specified file, or nil if the method could not find the specified image.
        </returns>
        <remarks><para>This method looks in the system caches for an image object with the specified name and returns that object if it exists. If a matching image object is not already in the cache, this method loads the image data from the specified file, caches it, and then returns the resulting object.</para>
        <para>On a device running iOS 4 or later, the behavior is identical if the device’s screen has a scale of 1.0. If the screen has a scale of 2.0, this method first searches for an image file with the same filename with an @2x suffix appended to it. For example, if the file’s name is button, it first searches for button@2x. If it finds a 2x, it loads that image and sets the scale property of the returned UIImage object to 2.0. Otherwise, it loads the unmodified filename and sets the scale property to 1.0. See iOS App Programming Guide for more information on supporting images with different scale factors.</para>
        <para>On iOS 4 and later, if the file is in PNG format, it is not necessary to specify the .PNG filename extension. Prior to iOS 4, you must specify the filename extension.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromFile">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage FromFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage FromFile(string filename) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("imageWithContentsOfFile:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The full or partial path to the file.</param>
        <summary>Creates and returns an image object by loading the image data from the file at the specified path.</summary>
        <returns>A new image object for the specified file, or nil if the method could not initialize the image from the specified file.</returns>
        <remarks>This method does not cache the image object.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromFileUncached">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage FromFileUncached (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage FromFileUncached(string filename) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This is identical to FromFile. Caching is done when using FromBundle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">contains the path of the image file to load.</param>
        <summary>Alias to FromFile, merely with a more explicit name to draw attention to the cache-less nature of this call compared to FromBundle.</summary>
        <returns>
        </returns>
        <remarks>Unlike the FromBundle method that keeps a cache of images in memory based on their path name, this method merely loads the image and keeps no internal copies in a cache.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromImage">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage FromImage (MonoTouch.CoreGraphics.CGImage image);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage FromImage(class MonoTouch.CoreGraphics.CGImage image) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("imageWithCGImage:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="MonoTouch.CoreGraphics.CGImage" />
      </Parameters>
      <Docs>
        <param name="image">The Quartz image object.</param>
        <summary>Creates and returns an image oject representing the specified Quartz image.</summary>
        <returns>A new image object for the specified Quartz image, or null if the method could not initialize the image from the specified image reference.</returns>
        <remarks>This method does not cache the image object. You can use the methods of the Core Graphics framework to create a Quartz image reference.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResource">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage FromResource (System.Reflection.Assembly assembly, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage FromResource(class System.Reflection.Assembly assembly, string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assembly">The resource is looked up in this assembly.   If the value is null, the resource is looked up in the assembly that calls this method.</param>
        <param name="name">The name of the embedded resource</param>
        <summary>Loads an image from a resource embedded in the assembly.</summary>
        <returns>The image loaded from the specified assembly.</returns>
        <remarks>If the passed parameter for assembly is null, then the resource is looked up in the calling assembly using <see cref="T:System.Reflection.Assembly.GetCallingAssembly()" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="Images">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIImage[] Images { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIImage[] Images" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("images")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For an animated image, this property holds the complete array of UIImage objects that make up the animation. (read-only)</summary>
        <value>To be added.</value>
        <remarks><para>For a non-animated image, the value of this property is nil.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftCapWidth">
      <MemberSignature Language="C#" Value="public virtual int LeftCapWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LeftCapWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("leftCapWidth")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The horizontal end-cap size. Deprecated in iOS 5.0. Use the capInsets property instead. (read-only)</summary>
        <value>To be added.</value>
        <remarks><para>End caps specify the portion of an image that should not be resized when an image is stretched. This technique is used to implement buttons and other resizable image-based interface elements. When a button with end caps is resized, the resizing occurs only in the middle of the button, in the region between the end caps. The end caps themselves keep their original size and appearance.</para>
        <para>This property specifies the size of the left end cap. The middle (stretchable) portion is assumed to be 1 pixel wide. The right end cap is therefore computed by adding the size of the left end cap and the middle portion together and then subtracting that value from the width of the image
        <code lang="C#">rightCapWidth = image.size.width - (image.leftCapWidth + 1);</code>          
        </para>
        <para>By default, this property is set to 0, which indicates that the image does not use end caps and the entire image is subject to stretching. To create a new image with a nonzero value for this property, use the stretchableImageWithLeftCapWidth:topCapHeight: method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromData">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UIImage LoadFromData (MonoTouch.Foundation.NSData data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UIImage LoadFromData(class MonoTouch.Foundation.NSData data) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("imageWithData:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
      </Parameters>
      <Docs>
        <param name="data">The image data. This can be data from a file or data you create programatically.</param>
        <summary>Creates and returns an image object that uses the specified image data.</summary>
        <returns>A new image object for the specified data or null if the method could not initialize the image from the specified data.</returns>
        <remarks>This method does not cache the image object.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIImageOrientation Orientation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIImageOrientation Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("imageOrientation")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImageOrientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The orientation of the receiver's image. (read-only)</summary>
        <value>To be added.</value>
        <remarks><para>Image orientation affects the way the image data is displayed when drawn. By default, images are displayed in the “up” orientation. If the image has associated metadata (such as EXIF information), however, this property contains the orientation indicated by that metadata. For a list of possible values for this property, see UIImageOrientation.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveToPhotosAlbum">
      <MemberSignature Language="C#" Value="public void SaveToPhotosAlbum (MonoTouch.UIKit.UIImage.SaveStatus status);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveToPhotosAlbum(class MonoTouch.UIKit.UIImage/SaveStatus status) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="status" Type="MonoTouch.UIKit.UIImage+SaveStatus" />
      </Parameters>
      <Docs>
        <param name="status">If not-null, a method to invoke when the file has been saved to the Camera Album.</param>
        <summary>Saves the specified image into the Photos Album.</summary>
        <remarks>
          <para>On systems without a camera, the Camera Album is the Saved Photos album instead.   This can not be changed.</para>
          <para>If a non-null value was specified for <paramref name="status" /> then the method is invoked on completion with both the image reference and an if there was an error, a non-null instance of NSError.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UIImage Scale (System.Drawing.SizeF newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.UIKit.UIImage Scale(valuetype System.Drawing.SizeF newSize) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newSize" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="newSize">The desired size for the scaled image.</param>
        <summary>Scales the image up or down.</summary>
        <returns>The scaled image.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("size")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The dimensions of the image, taking orientation into account. (read-only)</summary>
        <value>To be added.</value>
        <remarks>In iOS 4.0 and later, this value reflects the logical size of the image and is measured in points. In iOS 3.x and earlier, this value always reflects the dimensions of the image measured in pixels.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StretchableImage">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIImage StretchableImage (int leftCapWidth, int topCapHeight);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UIImage StretchableImage(int32 leftCapWidth, int32 topCapHeight) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("stretchableImageWithLeftCapWidth:topCapHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIImage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="leftCapWidth" Type="System.Int32" />
        <Parameter Name="topCapHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="leftCapWidth">The value to use for the left cap width. Specify 0 if you want the entire image to be horizontally stretchable. For a discussion of how a non-zero value affects the image, see the leftCapWidth property.</param>
        <param name="topCapHeight">The value to use for the top cap width. Specify 0 if you want the entire image to be vertically stretchable. For a discussion of how a non-zero value affects the image, see the topCapHeight property.</param>
        <summary>Creates and returns a new image object with the specified cap values. Deprecated. Use the resizableImageWithCapInsets: instead, specifying cap insets such that the interior is a 1x1 area.</summary>
        <returns>A new image object with the specified cap values.</returns>
        <remarks><para>During scaling or resizing of the image, areas covered by a cap are not scaled or resized. Instead, the 1-pixel wide area not covered by the cap in each direction is what is scaled or resized. This technique is often used to create variable-width buttons, which retain the same rounded corners but whose center region grows or shrinks as needed.</para>
        <para>You use this method to add cap values to an image or to change the existing cap values of an image. In both cases, you get back a new image and the original image remains untouched.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopCapHeight">
      <MemberSignature Language="C#" Value="public virtual int TopCapHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TopCapHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("topCapHeight")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The vertical end-cap size. Deprecated in iOS 5.0. Use the capInsets property instead. (read-only) </summary>
        <value>To be added.</value>
        <remarks><para>End caps specify the portion of an image that should not be resized when an image is stretched. This technique is used to implement buttons and other resizable image-based interface elements. When a button with end caps is resized, the resizing occurs only in the middle of the button, in the region between the end caps. The end caps themselves keep their original size and appearance.</para>
        <para>This property specifies the size of the top end cap. The middle (stretchable) portion is assumed to be 1 pixel wide. The bottom end cap is therefore computed by adding the size of the top end cap and the middle portion together and then subtracting that value from the height of the image:<code lang="C#">bottomCapHeight = image.size.height - (image.topCapHeight + 1);</code></para>
        <para>By default, this property is set to 0, which indicates that the image does not use end caps and the entire image is subject to stretching. To create a new image with a nonzero value for this property, use the stretchableImageWithLeftCapWidth:topCapHeight: method.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
