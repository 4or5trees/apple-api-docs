<Type Name="UITableView" FullName="MonoTouch.UIKit.UITableView">
  <TypeSignature Language="C#" Value="public class UITableView : MonoTouch.UIKit.UIScrollView" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UITableView extends MonoTouch.UIKit.UIScrollView" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.UIKit.UIScrollView</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UITableView", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A table view is used to display and edit hierarchical lists of information. A UITableView is limited to a single column because it is designed for a small screen.</summary>
    <remarks>
      <para>UITableView is a subclass of <see cref="T:MonoTouch.UIKit.UIScrollView" /> which allows users to scroll through the table, although only vertical scrolling is allowed. The table consists of <see cref="T:MonoTouch.UIKit.UITableViewCell" /> objects which are used to render the rows of the table. Cells have content - titles and images - and can also show accessories (such as disclosure arrows or input controls) on the right-side. UITableViews can enter an edit-mode where rows can be inserted, deleted and reordered.</para>
      <para>A table view can contain zero or more sections, each with its own rows. Sections can optionally display a header and footer.</para>
      <para>Table views must specify a style when created, which cannot be changed. There are two <see cref="T:MonoTouch.UIKit.UITableViewStyle" /> styles: Plain and Grouped. The Plain style allows the section headers and footers to remain visible as the section is scrolled through, and can optionally support an index that appears along the right edge to quickly scroll to a specific section. The Grouped style displays sections in rounded-rectangles that visually group the rows, and provides a default background image behind the scrolling list. Grouped tables should not provide an index.</para>
      <para>Each row in a table view is referenced by its section index and row number within that section, using an <see cref="T:MonoTouch.Foundation.NSIndexPath" /> object. Use <see cref="M:MonoTouch.Foundation.NSIndexPath.FromRowSection(int,int)" /> to construct an <see cref="T:MonoTouch.Foundation.NSIndexPath" /> that refers to a specific section/row.</para>
      <para>A UITableView must have an associated <see cref="T:MonoTouch.UIKit.UITableViewSource" /> subclass that provides the information required to display data in <see cref="T:MonoTouch.UIKit.UITableViewCell" /> objects and manage the data model when rows are inserted, deleted or reordered. The <see cref="T:MonoTouch.UIKit.UITableViewSource" /> also manages selection of rows, displaying an index and accessory views (if required).</para>
      <para>UITableView caches <see cref="T:MonoTouch.UIKit.UITableViewCell" /> objects only for visible rows, but caches the heights of rows, headers and footers for the entire table. It is possible to create custom <see cref="T:MonoTouch.UIKit.UITableViewCell" /> objects with varying heights and custom layouts.</para>
      <para>UITableView overrides <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" /> so that it calls <see cref="M:MonoTouch.UIKit.UITableView.ReloadData" /> only when you create a new instance or when you assign a new <see cref="P:MonoTouch.UIKit.UITableView.Source" /> (or <see cref="P:MonoTouch.UIKit.UITableView.DataSource" />).Reloading the table view clears current state (including the current selection). However if you explicitly call <see cref="M:MonoTouch.UIKit.UITableView.ReloadData()" /> it clears this state and any subsequent direct or indirect call to <see cref="M:MonoTouch.UIKit.UIView.LayoutSubviews()" /> does not trigger a reload.</para>
    </remarks>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=8325839c-471c-4409-8d96-caefe8a95d4a">Example_Data</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=23a2571b-45eb-4889-bb67-d88937cb68c1">monocatalog</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=a96da854-7c59-4e25-9fb5-78be262620dd">RecipesAndPrinting</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Default constructor that initializes a new instance of this class with no parameters.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advatnage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsability to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (System.Drawing.RectangleF frame);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="frame">Frame used by the view, expressed in iOS points.</param>
        <summary>Initializes the UITableView with the specified frame.</summary>
        <remarks>
          <para>This constructor is used to programatically create a new instance of UITableView with the specified dimension in the frame.   The object will only be displayed once it has been added to a view hierarchy by calling AddSubview in a containing view.</para>
          <para>This constructor is not invoked when deserializing objects from storyboards or XIB filesinstead the constructor that takes an NSCoder parameter is invoked.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UITableView (System.Drawing.RectangleF frame, MonoTouch.UIKit.UITableViewStyle style);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.RectangleF frame, valuetype MonoTouch.UIKit.UITableViewStyle style) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithFrame:style:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="frame" Type="System.Drawing.RectangleF" />
        <Parameter Name="style" Type="MonoTouch.UIKit.UITableViewStyle" />
      </Parameters>
      <Docs>
        <param name="frame">A rectangle specifying the initial location and size of the table view.</param>
        <param name="style">
          <see cref="T:MonoTouch.UIKit.UITableViewStyle" />: Plain or Grouped.</param>
        <summary>Creates a table view with the given <see cref="P:MonoTouch.UIKit.UITableView.Frame" /> and <see cref="T:MonoTouch.UIKit.UITableViewStyle" />.</summary>
        <remarks>You must specify the style of a table when you create it. You cannot change a table view's style. If you use the <see cref="C:MonoTouch.UIKit.UITableView(System.Drawing.RectangleF)" /> constructor, the Plain style is used by default.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsMultipleSelection">
      <MemberSignature Language="C#" Value="public virtual bool AllowsMultipleSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsMultipleSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsMultipleSelection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsMultipleSelection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether more than one row can be selected (outside of editing mode).</summary>
        <value>
          <see langword="false" /> if multiple selection is prohibited, <see langword="true" /> if it is allowed.</value>
        <remarks>
          <para>When this property is <see langword="true" />, a check mark is placed next to each row that is tapped. Tapping the row again removes the check mark.</para>
          <para>Call <see cref="M:MonoTouch.UIKit.UITableView.IndexPathsForSelectedRows" /> to identify the selected rows.</para>
          <para>The default value of this property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsMultipleSelectionDuringEditing">
      <MemberSignature Language="C#" Value="public virtual bool AllowsMultipleSelectionDuringEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsMultipleSelectionDuringEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsMultipleSelectionDuringEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsMultipleSelectionDuringEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether more than one row can be selected while in editing mode.</summary>
        <value>
          <see langword="false" /> if multiple selection is prohibited, <see langword="true" /> if it is allowed.</value>
        <remarks>
          <para>When this property is <see langword="true" />, a check mark is placed next to each row that is tapped. Tapping the row again removes the check mark. In addition, the UITableView does not query for editing styles when it goes into editing mode.</para>
          <para>Call <see cref="M:MonoTouch.UIKit.UITableView.IndexPathsForSelectedRows" /> to identify the selected rows.</para>
          <para>The default value of this property is <see langword="false" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsSelection">
      <MemberSignature Language="C#" Value="public virtual bool AllowsSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsSelection")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsSelection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether a row can be selected.</summary>
        <value>
          <see langword="true" /> if row selection is allowed, <see langword="false" /> if not.</value>
        <remarks>If <see langword="true" /> (the default) then row selection is allowed. This property only affects cell selection when the table view is not in editing mode. To control selection in edting mode, use <see cref="P:MonoTouch.UIKit.UITableView.AllowsSelectionDuringEditing" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsSelectionDuringEditing">
      <MemberSignature Language="C#" Value="public virtual bool AllowsSelectionDuringEditing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsSelectionDuringEditing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("allowsSelectionDuringEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setAllowsSelectionDuringEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether a row can be selected while in editing mode.</summary>
        <value>
          <see langword="true" /> if row selection is allowed, <see langword="false" /> if not. The default is <see langword="false" />.</value>
        <remarks>If <see langword="true" /> then row selection is allowed during editing. This property only affects cell selection when the table view is in editing mode. To control selection in normal mode, use <see cref="P:MonoTouch.UIKit.UITableView.AllowsSelection" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Appearance">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableView.UITableViewAppearance Appearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.UIKit.UITableView/UITableViewAppearance Appearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Strongly-typed property that returns the UIAppearance class for this class.</summary>
        <value>
        </value>
        <remarks>Setting any appearance properties on this instance will affect the appearance of all instances of UITableView.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppearanceWhenContainedIn">
      <MemberSignature Language="C#" Value="public static MonoTouch.UIKit.UITableView.UITableViewAppearance AppearanceWhenContainedIn (Type[] containers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.UIKit.UITableView/UITableViewAppearance AppearanceWhenContainedIn(class System.Type[] containers) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableView+UITableViewAppearance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containers" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="containers">List of types that you want to have as the containers to apply this particular appearance</param>
        <summary>Returns a strongly typed UIAppearance for instances of this class when the view is hosted in the specified hierarchy.</summary>
        <returns>The appearance proxy object that you can use to set properties when the given container hierarchy is active</returns>
        <remarks>
          <para>The returned object represents the UIAppearance proxy where you can set appearance properties for instances of UITableView when those instances are contained in the hierarchy specified by the <see paramref="containers" /> parameter.</para>
          <para>The following example shows how the AppearanceWhenContainedIn method works</para>
          <example>
            <code lang="C#">
var mySliders = UISlider.AppearanceWhenContainedIn (typeof (UINavigationBar), typeof (UIPopoverController));
mySliders.TintColor = UIColor.Red;
</code>
          </example>
          <para>For more information, see the documentation for the <see cref="T:MonoTouch.UIKit.UIAppearance" /> class.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDimension">
      <MemberSignature Language="C#" Value="public static float AutomaticDimension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float32 AutomaticDimension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Constant value to indicate that the table view should use a default value for the dimension.</summary>
        <value>
        </value>
        <remarks>Return this value from <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="T:MonoTouch.UIKit.UITableViewDelegate" />) methods that request dimension metrics when you want the UITableView to use a default value. For example, return this constant from <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForHeader" /> or <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForFooter" /> and the table view will use automatically use a height that accomodates the value returned from <see cref="M:MonoTouch.UIKit.UITableViewSource.TitleForHeader" /> or <see cref="M:MonoTouch.UIKit.UITableViewSource.TitleForFooter" /> respectively.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView BackgroundView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView BackgroundView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(3, 2)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("backgroundView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setBackgroundView:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The background view of the table.</summary>
        <value>A <see cref="T:MonoTouch.UIKit.UIView" /><para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>A table view's background view is automatically resized to match the size of the table view. The background view is placed as a subview of the table behind all cell, header and footer views.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUpdates">
      <MemberSignature Language="C#" Value="public virtual void BeginUpdates ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginUpdates() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("beginUpdates")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Call this method before inserting, updating or selecting rows that you wish to animate as one operation. <see cref="M:MonoTouch.UIKit.UITableView.EndUpates" /> must be called after the modifications are complete.</summary>
        <remarks>
          <para>After calling this method, subsequent insertions, deletions and selection operations (eg. <see cref="M:MonoTouch.UIKit.UITableView.IndexPathsForVisibleRows" /> or <see cref="M:MonoTouch.UIKit.UITableView.CellAt" />) will be animated simultaneously. This group of methods must conclude with a call to <see cref="M:MonoTouch.UIKit.UITableView.EndUpates" />. These method pairs can be nested.</para>
          <para>If you do not make the insertion, deletion and selection calls inside this block, table attributes such as row count might become invalid. Do not call <see cref="M:MonoTouch.UIKit.UITableView.ReloadData" /> within the group, otherwise you will need to perform any animations manually.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CellAt">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCell CellAt (MonoTouch.Foundation.NSIndexPath ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewCell CellAt(class MonoTouch.Foundation.NSIndexPath ns) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cellForRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="ns">An <see cref="T:MonoTouch.Foundation.NSIndexPath" /> that references a row in the table view.</param>
        <summary>Returns the table cell at the specified index path.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewCell" /> object that represents a row in the table, or <see langword="null" /> if the row is not visible or the <see cref="T:MonoTouch.Foundation.NSIndexPath" /> is out of range.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewDataSource DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewDataSource DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewDataSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The object that acts as the data source for the table view.</summary>
        <value>
          <para>
          </para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>
          <para>The data source must subclass <see cref="T:MonoTouch.UIKit.UITableViewDataSource" />. MonoTouch provides an alternative to implementing both <see cref="T:MonoTouch.UIKit.UITableViewDataSource" /> and <see cref="T:MonoTouch.UIKit.UITableViewDelegate" />: the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> class which should be assigned to <see cref="P:MonoTouch.UIKit.UITableView.Source" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewDelegate Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the MonoTouch.UIKit.UITableViewDelegate model class which acts as the class delegate.</summary>
        <value><para>The instance of the MonoTouch.UIKit.UITableViewDelegate model class</para><para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, use the WeakDelegate property instead if you want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteRows">
      <MemberSignature Language="C#" Value="public virtual void DeleteRows (MonoTouch.Foundation.NSIndexPath[] atIndexPaths, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteRows(class MonoTouch.Foundation.NSIndexPath[] atIndexPaths, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("deleteRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="MonoTouch.Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">Array of <see cref="MonoTouch.Foundation.NSIndexPath" /> objects that identify which rows to delete.</param>
        <param name="withRowAnimation">What type of animation to use when deleting the rows (eg. fade out or slide out from bottom). </param>
        <summary>Delete the rows referenced in the <paramref name="atIndexPaths" /> array. The deletion can optionally be animated.</summary>
        <remarks>
          <para>When this method is called inside an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteSections">
      <MemberSignature Language="C#" Value="public virtual void DeleteSections (MonoTouch.Foundation.NSIndexSet sections, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteSections(class MonoTouch.Foundation.NSIndexSet sections, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("deleteSections:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="MonoTouch.Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">A set of section identifiers to delete. If a section exists after one that is deleted, it is moved up one index location.</param>
        <param name="withRowAnimation">What type of animation to use when deleting the rows (eg. fade out or slide out from bottom).</param>
        <summary>Deletes a section (or sections) from a table view, with an option to animate the operation.</summary>
        <remarks>
          <para>When this method is called inside an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewCell DequeueReusableCell (MonoTouch.Foundation.NSString identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.UIKit.UITableViewCell DequeueReusableCell(class MonoTouch.Foundation.NSString identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dequeueReusableCellWithIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="identifier">A string identifying the cell object to be reused.</param>
        <summary>Returns a reusable table view cell that was created with the given ReuseIdentifier.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />, or <see langword="null" /> if there is no cells in the queue with that particular <paramref name="identifier" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCell DequeueReusableCell (string identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewCell DequeueReusableCell(string identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dequeueReusableCellWithIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="identifier">A string identifying the cell object to be reused.</param>
        <summary>Returns a reusable table view cell that was created with the given ReuseIdentifier.</summary>
        <returns>A <see cref="T:MonoTouch.UIKit.UITableViewCell" /> associated with the <paramref name="identifier" />, or <see langword="null" /> if there is no cells in the queue with that particular <paramref name="identifier" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableCell">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject DequeueReusableCell (MonoTouch.Foundation.NSString reuseIdentifier, MonoTouch.Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSObject DequeueReusableCell(class MonoTouch.Foundation.NSString reuseIdentifier, class MonoTouch.Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dequeueReusableCellWithIdentifier:forIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">To be added.</param>
        <param name="indexPath">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DequeueReusableHeaderFooterView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject DequeueReusableHeaderFooterView (MonoTouch.Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSObject DequeueReusableHeaderFooterView(class MonoTouch.Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dequeueReusableHeaderFooterViewWithIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="reuseIdentifier">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeselectRow">
      <MemberSignature Language="C#" Value="public virtual void DeselectRow (MonoTouch.Foundation.NSIndexPath indexPath, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeselectRow(class MonoTouch.Foundation.NSIndexPath indexPath, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("deselectRowAtIndexPath:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="indexPath">An <see cref="T:MonoTouch.Foundation.NSIndexPath" /> identifying a row in the table view.<para tool="nullallowed">This parameter can be <see langword="null" />.</para></param>
        <param name="animated">
          <see langword="true" /> if the deseletion should be animated, <see langword="false" /> if it should occur immediately.</param>
        <summary>Deselect a given row in a table view, with an option to animate the deselection.</summary>
        <remarks>
          <para>Calling this method does not trigger <see cref="M:MonoTouch.UIKit.UITableViewSource.WillSelectRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> nor will it send <see cref="P:MonoTouch.UIKit.UITableView.SelectionDidChangeNotification" /> notifications.</para>
          <para>This method does not cause any scrolling to the deselected row.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resourced used by the UITableView object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UITableView class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposting <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UITableView ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Editing">
      <MemberSignature Language="C#" Value="public virtual bool Editing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Editing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isEditing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setEditing:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Whether the table view is in editing mode.</summary>
        <value>
          <see langword="true" /> if the table is currently in editing mode, <see langword="false" /> if not. The default is <see langword="false" />.</value>
        <remarks>When this property is <see langword="true" />, the table view is in editing mode: cells may show an insertion or deletion control on their left side and a reordering control on the right (depending on how the cell is configured). Tapping a control causes the table view to invoke the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> method <see cref="M:MonoTouch.UIKit.UITableViewSource.CommitEditingStyle" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUpdates">
      <MemberSignature Language="C#" Value="public virtual void EndUpdates ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndUpdates() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("endUpdates")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finalize a series of method calls that insert, update or select rows to animate as one operation. <see cref="M:MonoTouch.UIKit.UITableView.BeginUpates()" /> must be called before the modifications are made.</summary>
        <remarks>Call this method to bracket a series of table modifications (insert, delete or select rows) that began with <see cref="M:MonoTouch.UIKit.UITableView.BeginUpates()" />. When EndUpdates is called the table view animates the operations simultaneously. Calls to <see cref="M:MonoTouch.UIKit.UITableView.BeginUpates()" /> and EndUpdates can be nested. If you make insertion, deletion or selection calls outside of a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpates()" />/EndUpdates block then table attributes such as row count might become invalid.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFooterView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewHeaderFooterView GetFooterView (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewHeaderFooterView GetFooterView(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("footerViewForSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHeaderView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewHeaderFooterView GetHeaderView (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.UIKit.UITableViewHeaderFooterView GetHeaderView(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("headerViewForSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewHeaderFooterView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForCell">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath IndexPathForCell (MonoTouch.UIKit.UITableViewCell cell);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSIndexPath IndexPathForCell(class MonoTouch.UIKit.UITableViewCell cell) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("indexPathForCell:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="MonoTouch.UIKit.UITableViewCell" />
      </Parameters>
      <Docs>
        <param name="cell">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForRowAtPoint">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath IndexPathForRowAtPoint (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSIndexPath IndexPathForRowAtPoint(valuetype System.Drawing.PointF point) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("indexPathForRowAtPoint:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathForSelectedRow">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath IndexPathForSelectedRow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSIndexPath IndexPathForSelectedRow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indexPathForSelectedRow")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathsForSelectedRows">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath[] IndexPathsForSelectedRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSIndexPath[] IndexPathsForSelectedRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indexPathsForSelectedRows")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexPathsForVisibleRows">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSIndexPath[] IndexPathsForVisibleRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSIndexPath[] IndexPathsForVisibleRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("indexPathsForVisibleRows")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSIndexPath[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexSearch">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString IndexSearch { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString IndexSearch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertRows">
      <MemberSignature Language="C#" Value="public virtual void InsertRows (MonoTouch.Foundation.NSIndexPath[] atIndexPaths, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertRows(class MonoTouch.Foundation.NSIndexPath[] atIndexPaths, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="MonoTouch.Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">To be added.</param>
        <param name="withRowAnimation">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertSections">
      <MemberSignature Language="C#" Value="public virtual void InsertSections (MonoTouch.Foundation.NSIndexSet sections, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void InsertSections(class MonoTouch.Foundation.NSIndexSet sections, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("insertSections:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="MonoTouch.Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">A set of section identifiers to insert. If a section already exists at a given index, it is moved up down one index location.</param>
        <param name="withRowAnimation">What type of animation to use when deleting the rows (eg. fade in or slide in from left)</param>
        <summary>Inserts a section (or sections) from a table view, with an option to animate the operation.</summary>
        <remarks>
          <para>UITableView calls the relevant <see cref="T:MonoTouch.UIKit.UITableViewSource" /> methods immediately afterwards to get the cells and other content to display the visible rows.</para>
          <para>When this method is called inside an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" />, any insertions of rows or sections are deferred until after deletions have been processed. This happens regardless of the ordering of the insertion and deletion method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveRow">
      <MemberSignature Language="C#" Value="public virtual void MoveRow (MonoTouch.Foundation.NSIndexPath fromIndexPath, MonoTouch.Foundation.NSIndexPath toIndexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveRow(class MonoTouch.Foundation.NSIndexPath fromIndexPath, class MonoTouch.Foundation.NSIndexPath toIndexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("moveRowAtIndexPath:toIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromIndexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="toIndexPath" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="fromIndexPath">To be added.</param>
        <param name="toIndexPath">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveSection">
      <MemberSignature Language="C#" Value="public virtual void MoveSection (int fromSection, int toSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveSection(int32 fromSection, int32 toSection) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("moveSection:toSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromSection" Type="System.Int32" />
        <Parameter Name="toSection" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="fromSection">Index of the section to move.</param>
        <param name="toSection">Destination index for the section. The section currently at this index is moved up or down to accomodate the moved section.</param>
        <summary>Moves a section to a new location in the table view.</summary>
        <remarks>
          <para>This method can be combined with other MoveSection, <see cref="M:MonoTouch.UIKit.UITableView.InsertSections(MonoTouch.Foundation.NSIndexSet,MonoTouch.UIKit.UITableViewRowAnimation)" /> and <see cref="M:MonoTouch.UIKit.UITableView.DeleteSections(MonoTouch.Foundation.NSIndexSet,MonoTouch.UIKit.UITableViewRowAnimation)" /> operations within an animation block defined by <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" /> and <see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" />, so that all the changes occur in a single animation.</para>
          <para>Unlike the insertion and deletion methods, moving a section does not use an animation paramter. Moved sections always animate straight from their starting position to their new position. Only one section can be moved per method call, however to move mulitple sections you can call this method repeatedly within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" /> animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfRowsInSection">
      <MemberSignature Language="C#" Value="public virtual int NumberOfRowsInSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 NumberOfRowsInSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("numberOfRowsInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of the section to query. Section indexes start at zero.</param>
        <summary>Returns the number of rows (table cells) in a given section.</summary>
        <returns>Number of rows in the section.</returns>
        <remarks>UITableView retrieves this value from the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="T:MonoTouch.UIKit.UITableViewDataSource" />) and caches it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfSections">
      <MemberSignature Language="C#" Value="public virtual int NumberOfSections ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 NumberOfSections() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("numberOfSections")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the number of sections in the table view.</summary>
        <returns>Number of sections in the table view.</returns>
        <remarks>UITableView retrieves this value from the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="T:MonoTouch.UIKit.UITableViewDataSource" />) and caches it.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForFooterInSection">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForFooterInSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForFooterInSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForFooterInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section's footer.</summary>
        <returns>A rectangle defining where the section footer is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForHeaderInSection">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForHeaderInSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForHeaderInSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForHeaderInSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section's header.</summary>
        <returns>A rectangle defining where the section header is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForRowAtIndexPath">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForRowAtIndexPath (MonoTouch.Foundation.NSIndexPath indexPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForRowAtIndexPath(class MonoTouch.Foundation.NSIndexPath indexPath) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForRowAtIndexPath:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
      </Parameters>
      <Docs>
        <param name="indexPath">An index path to a specific row in the table view.</param>
        <summary>Returns the drawing area for the specified row.</summary>
        <returns>A rectangle defining where the row is drawn by the table view, or <see cref="T:MonoTouch.CoreGraphics.CGRectZero" /> if the <paramref name="indexPath" /> is not valid.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RectForSection">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.RectangleF RectForSection (int section);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.RectangleF RectForSection(int32 section) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rectForSection:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="section" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="section">The index of a section.</param>
        <summary>Returns the drawing area for the specified section.</summary>
        <returns>A rectangle defining where the section is drawn by the table view.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForCellReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForCellReuse (Type cellType, MonoTouch.Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForCellReuse(class System.Type cellType, class MonoTouch.Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="cellType">To be added.</param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public void RegisterClassForHeaderFooterViewReuse (Type cellType, MonoTouch.Foundation.NSString reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClassForHeaderFooterViewReuse(class System.Type cellType, class MonoTouch.Foundation.NSString reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cellType" Type="System.Type" />
        <Parameter Name="reuseIdentifier" Type="MonoTouch.Foundation.NSString" />
      </Parameters>
      <Docs>
        <param name="cellType">To be added.</param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibforCellReuse">
      <MemberSignature Language="C#" Value="public void RegisterNibforCellReuse (MonoTouch.UIKit.UINib nib, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterNibforCellReuse(class MonoTouch.UIKit.UINib nib, string reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use RegisterNibForCellReuse")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="MonoTouch.UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">A nib object created from a nib file. This value cannot be null.</param>
        <param name="reuseIdentifier">A string to use as an identifier for the cell. This value cannot be null.</param>
        <summary>Registers a nib object (containing a <see cref="T:MonoTouch.UIKit.UITableViewCell" />) with the given identifer string.</summary>
        <remarks>After a nib object has been registered with a table view, calling <see cref="M:MonoTouch.UIKit.UITableView.DequeueReusableCell(MonoTouch.Foundation.NSString)" /> with the correct identifer will cause the table view to instantiate the cell from the nib object if there is not already an instance in the reuse queue.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForCellReuse">
      <MemberSignature Language="C#" Value="public virtual void RegisterNibForCellReuse (MonoTouch.UIKit.UINib nib, string reuseIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterNibForCellReuse(class MonoTouch.UIKit.UINib nib, string reuseIdentifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerNib:forCellReuseIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="MonoTouch.UIKit.UINib" />
        <Parameter Name="reuseIdentifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">To be added.</param>
        <param name="reuseIdentifier">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNibForHeaderFooterViewReuse">
      <MemberSignature Language="C#" Value="public virtual void RegisterNibForHeaderFooterViewReuse (MonoTouch.UIKit.UINib nib, string identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterNibForHeaderFooterViewReuse(class MonoTouch.UIKit.UINib nib, string identifier) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("registerNib:forHeaderFooterViewReuseIdentifier:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nib" Type="MonoTouch.UIKit.UINib" />
        <Parameter Name="identifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nib">To be added.</param>
        <param name="identifier">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadData">
      <MemberSignature Language="C#" Value="public virtual void ReloadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadData() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadData")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the rows and sections in the table view.</summary>
        <remarks>
          <para>This method reloads all the data in the table, including cells, headers, footers and the index array. For efficiency, only visible rows are have their cells loaded and displayed.</para>
          <para>A table view's <see cref="P:MonoTouch.UIKit.UITableView.Source" /> calls this method when it wants to completely reload data. This method should not be called inside other methods that insert or delete rows, especially within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" /> animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadRows">
      <MemberSignature Language="C#" Value="public virtual void ReloadRows (MonoTouch.Foundation.NSIndexPath[] atIndexPaths, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadRows(class MonoTouch.Foundation.NSIndexPath[] atIndexPaths, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadRowsAtIndexPaths:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atIndexPaths" Type="MonoTouch.Foundation.NSIndexPath[]" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="atIndexPaths">An array of <see cref="T:MonoTouch.Foundation.NSIndexPath" /> objects that indicate which rows to reload.</param>
        <param name="withRowAnimation">The type of animation to use. The animation chosen affects both the way the old cell is animated out as well as how the new cell is animated into view.</param>
        <summary>Reloads specific rows with the given animation effect.</summary>
        <remarks>
          <para>Reloading a row means the data source is asked for a new cell for that row, which the table animates into place (animating the old cell off screen). Use this method to alert the user that the value of the cell is changing. If notifying the user is not important simply get the cell for a particular row and update its value.</para>
          <para>When this method is called within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" /> animation block it behaves like <see cref="M:MonoTouch.UIKit.DeleteRows(MonoTouch.Foundation.NSIndexPath[],MonoTouch.UIKit.UITableViewRowAnimation)" /> - the indexes passed to the method are specified in the state of the table view prior to any updates. This happens regardless of the order of the insertion, deletion and reloading method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadSectionIndexTitles">
      <MemberSignature Language="C#" Value="public virtual void ReloadSectionIndexTitles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadSectionIndexTitles() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadSectionIndexTitles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the index bar long the right edge of a table view.</summary>
        <remarks>Use this method to update the index after inserting or deleting sections, without having to reload the entire table.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReloadSections">
      <MemberSignature Language="C#" Value="public virtual void ReloadSections (MonoTouch.Foundation.NSIndexSet sections, MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReloadSections(class MonoTouch.Foundation.NSIndexSet sections, valuetype MonoTouch.UIKit.UITableViewRowAnimation withRowAnimation) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("reloadSections:withRowAnimation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sections" Type="MonoTouch.Foundation.NSIndexSet" />
        <Parameter Name="withRowAnimation" Type="MonoTouch.UIKit.UITableViewRowAnimation" />
      </Parameters>
      <Docs>
        <param name="sections">The sections to be reloaded.</param>
        <param name="withRowAnimation">Specifies which animation effect to use. This determines how the old sections are animated out as well as how the new sections are animated into view.</param>
        <summary>Reloads specific sections with an animation effect.</summary>
        <remarks>
          <para>Reloading a section means the data source is asked for news cell for the specified sections, which the table animates into place (animating the old cells off screen). Use this method to alert the user that the cells in the given sections are changing. If notifying the user is not important simply get the relevant cells and update their values directly.</para>
          <para>When this method is called within a <see cref="M:MonoTouch.UIKit.UITableView.BeginUpdates()" />-<see cref="M:MonoTouch.UIKit.UITableView.EndUpdates()" /> animation block it behaves like <see cref="M:MonoTouch.UIKit.DeleteRows(MonoTouch.Foundation.NSIndexPath[],MonoTouch.UIKit.UITableViewRowAnimation)" /> - the indexes passed to the method are specified in the state of the table view prior to any updates. This happens regardless of the order of the insertion, deletion and reloading method calls within the animation block.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowHeight">
      <MemberSignature Language="C#" Value="public virtual float RowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 RowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("rowHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setRowHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of each row in the table view.</summary>
        <value>Row height in points.</value>
        <remarks>
          <para>This property can be set if the <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> has not been implemented. If the row height is not set explicity the table view uses a default value.</para>
          <para>There are performance implications to using <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> instead of this property: every time a table view is displayed it calls <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> for each of its rows. This can result in poor performance when the table has a large number of rows (for example, 1000 rows or more).</para>
          <para>If every row in a table has the same height, use this property. If rows have different heights (for example, they are sized around a variable amount of text) then <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> is more appropriate.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToNearestSelected">
      <MemberSignature Language="C#" Value="public virtual void ScrollToNearestSelected (MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollToNearestSelected(valuetype MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("scrollToNearestSelectedRowAtScrollPosition:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="atScrollPosition" Type="MonoTouch.UIKit.UITableViewScrollPosition" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="atScrollPosition">Position that the target row should appear (e. top, middle, bottom) once the scrolling is complete.</param>
        <param name="animated">
          <paramref name="true" /> to animate the scroll,  <paramref name="false" /> if the table view should just jump immediately to the new position.</param>
        <summary>Automatically scrolls the rows so that the selected row nearest to a given position is moved to that position.</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRow">
      <MemberSignature Language="C#" Value="public virtual void ScrollToRow (MonoTouch.Foundation.NSIndexPath indexPath, MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ScrollToRow(class MonoTouch.Foundation.NSIndexPath indexPath, valuetype MonoTouch.UIKit.UITableViewScrollPosition atScrollPosition, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("scrollToRowAtIndexPath:atScrollPosition:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="atScrollPosition" Type="MonoTouch.UIKit.UITableViewScrollPosition" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="indexPath">Identifies which row should appear <paramref name="atScrollPosition" />.</param>
        <param name="atScrollPosition">Position that the target row should appear (e. top, middle, bottom) once the scrolling is complete.</param>
        <param name="animated">
          <paramref name="true" /> to animate the scroll,  <paramref name="false" /> if the table view should just jump immediately to the new position.</param>
        <summary>Automatically scrolls the table view until the specified row appears in the required position.</summary>
        <remarks>Calling this method does not trigger <see cref="M:MonoTouch.UIKit.UITableViewSource.Scrolled()" />, which would normally occur after a programmatically-invoked UI operation.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionFooterHeight">
      <MemberSignature Language="C#" Value="public virtual float SectionFooterHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 SectionFooterHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionFooterHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionFooterHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of section footers in the table view.</summary>
        <value>Height in points.</value>
        <remarks>This property is used only in section group tables, and only if <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForFooter(MonoTouch.UIKit.UITableView,System.Int32)" /> has not been implemented.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionHeaderHeight">
      <MemberSignature Language="C#" Value="public virtual float SectionHeaderHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 SectionHeaderHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionHeaderHeight")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionHeaderHeight:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The height of section headers in the table view.</summary>
        <value>Height in points.</value>
        <remarks>This property is used only in section group tables, and only if <see cref="M:MonoTouch.UIKit.UITableViewSource.GetHeightForHeader(MonoTouch.UIKit.UITableView,System.Int32)" /> has not been implemented.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor SectionIndexColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor SectionIndexColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionIndexColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionIndexColor:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance" /> styling system.  See the <see cref="P:MonoTouch.UIKit.UITableView.Appearance" /> property and the <see cref="M:MonoTouch.UIKit.UITableView.AppearanceWhenContainedIn" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexMinimumDisplayRowCount">
      <MemberSignature Language="C#" Value="public virtual int SectionIndexMinimumDisplayRowCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SectionIndexMinimumDisplayRowCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionIndexMinimumDisplayRowCount")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionIndexMinimumDisplayRowCount:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The number of rows required in a table view before the index list is displayed.</summary>
        <value>To be added.</value>
        <remarks>Only <see cref="T:MonoTouch.UIKit.UItableViewStyle" />.Plain styled tables should have an index. The default value is <see cref="T:MonoTouch.Foundation.NSIntegerMax" />.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionIndexTrackingBackgroundColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor SectionIndexTrackingBackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor SectionIndexTrackingBackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(6, 0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sectionIndexTrackingBackgroundColor")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSectionIndexTrackingBackgroundColor:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para id="tool-remark">This member participates in the <see cref="T:MonoTouch.UIKit.UIAppearance" /> styling system.  See the <see cref="P:MonoTouch.UIKit.UITableView.Appearance" /> property and the <see cref="M:MonoTouch.UIKit.UITableView.AppearanceWhenContainedIn" /> method.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionDidChangeNotification">
      <MemberSignature Language="C#" Value="public static MonoTouch.Foundation.NSString SelectionDidChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class MonoTouch.Foundation.NSString SelectionDidChangeNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Notification constant for SelectionDidChange</summary>
        <value>NSString constant, should be used as a token to NSNotificationCenter.</value>
        <remarks>
          <para id="tool-remark">This constant can be used with the <see cref="T:MonoTouch.Foundation.NSNotificationCenter" /> to register a listener for this notification.   This is an NSString instead of a string, because these values can be used as tokens in some native libraries instead of being used purely for their actual string content.    The 'notification' parameter to the callback contains extra information that is specific to the notification type.</para>
          <para id="tool-remark">If you want to subscribe to this notification, you can use the convenience <see cref="T:UITableView+Notifications" />.<see cref="M:UITableView+Notifications.ObserveSelectionDidChange" /> method which offers strongly typed access to the parameters of the notification.</para>
          <para>The following example shows how to use the strongly typed Notifications class, to take the guesswork out of the available properties in the notification:</para>
          <example>
            <code lang="c#">
//
// Lambda style
//

// listening
notification = UITableView.Notifications.ObserveSelectionDidChange ((sender, args) =&gt; {
    /* Access strongly typed args */
    Console.WriteLine ("Notification: {0}", args.Notification);
});

// To stop listening:
notification.Dispose ();

//
// Method style
//
NSObject notification;
void Callback (object sender, SelectionDidChange args)
{
    // Access strongly typed args
    Console.WriteLine ("Notification: {0}", args.Notification);
}

void Setup ()
{
    notification = UITableView.Notifications.ObserveSelectionDidChange (Callback);
}

void Teardown ()
{
    notification.Dispose ();
}</code>
          </example>
          <para>The following example shows how to use the notification with the DefaultCenter API:</para>
          <example>
            <code lang="c#">
// Lambda style
NSNotificationCenter.DefaultCenter.AddObserver (
        UITableView.SelectionDidChangeNotification, (notification) =&gt; {Console.WriteLine ("Received the notification UITableView", notification); }


// Method style
void Callback (NSNotification notification)
{
    Console.WriteLine ("Received a notification UITableView", notification);
}

void Setup ()
{
    NSNotificationCenter.DefaultCenter.AddObserver (UITableView.SelectionDidChangeNotification, Callback);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectRow">
      <MemberSignature Language="C#" Value="public virtual void SelectRow (MonoTouch.Foundation.NSIndexPath indexPath, bool animated, MonoTouch.UIKit.UITableViewScrollPosition scrollPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SelectRow(class MonoTouch.Foundation.NSIndexPath indexPath, bool animated, valuetype MonoTouch.UIKit.UITableViewScrollPosition scrollPosition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("selectRowAtIndexPath:animated:scrollPosition:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexPath" Type="MonoTouch.Foundation.NSIndexPath" />
        <Parameter Name="animated" Type="System.Boolean" />
        <Parameter Name="scrollPosition" Type="MonoTouch.UIKit.UITableViewScrollPosition" />
      </Parameters>
      <Docs>
        <param name="indexPath">Identifies the row to be selected.</param>
        <param name="animated">
          <see langword="true" /> to animate the selection and position change, <see langword="false" /> if the change should occur immediately.</param>
        <param name="scrollPosition">Position that the selected row should be scrolled to (top, middle, bottom).</param>
        <summary>Selects the given row, optionall scrolling the row to a specific location.</summary>
        <remarks>
          <para>Calling this method does not trigger <see cref="M:MonoTouch.UIKit.UITableViewSource.WillSelectRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /> nor will it send <see cref="P:MonoTouch.UIKit.UITableView.SelectionDidChangeNotification" /> notifications.</para>
        </remarks>
        <example>
          <para>Passing <see cref="P:MonoTouch.UIKit.UITableViewScrollPosition.None" />. will result in no scrolling (despite that constant normally causing minimal scrolling). To scroll to the newly selected row with minimum scrolling, select the row using this method with <see cref="P:MonoTouch.UIKit.UITableViewScrollPosition.None" /> then call <see cref="M:MonoTouch.UIKit.UITableView.ScrollToRow(MonoTouch.Foundation.NSIndexPath,MonoTouch.UIKit.UITableViewScrollPosition,System.Boolean)" /> also with <see cref="P:MonoTouch.UIKit.UITableViewScrollPosition.None" />.</para>
          <code lang="c#">
                  NSIndexPath rowToSelect; // assume this is valid
                  UITableView myTableView; // assume this is valid
                  
                  myTableView.SelectRow (rowToSelect, true, UITableViewScrollPosition.None);
                  myTableView.ScrollToRow (rowToSelect, UITableViewScrollPosition.None, true);
              </code>
        </example>
      </Docs>
    </Member>
    <Member MemberName="SeparatorColor">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIColor SeparatorColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIColor SeparatorColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("separatorColor", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSeparatorColor:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The color of the separator between rows in the table view.</summary>
        <value>The default color is grey.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeparatorStyle">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCellSeparatorStyle SeparatorStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewCellSeparatorStyle SeparatorStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("separatorStyle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setSeparatorStyle:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCellSeparatorStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The style of the separator between rows in the table view.</summary>
        <value>.</value>
        <remarks>UITableView uses this property to set the separator style on cells returned by <see cref="M:MonoTouch.UIKit.UITableViewSource.GetCell(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" /></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEditing">
      <MemberSignature Language="C#" Value="public virtual void SetEditing (bool editing, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetEditing(bool editing, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setEditing:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editing" Type="System.Boolean" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="editing">
          <see langword="true" /> to enter editing mode, <see langword="false" /> to end editing. The default is <see langword="false" />.</param>
        <param name="animated">
          <see langword="true" /> to animate the transition to or from editing mode, or <see langword="false" /> to change modes immediately.</param>
        <summary>Turns editing mode on or off.</summary>
        <remarks>
          <para>Calling this method with  <paramref name="editing" /> == <see langword="true" />, the table view enters editing mode and calls <see cref="M:MonoTouch.UIKit.UITableViewCell.SetEditing(bool,bool)" /> on each visible row's <see cref="T:MonoTouch.UIKit.UITableViewCell" /> object.</para>
          <para>In editing mode the cells might show </para>
          <para>The <see cref="T:MonoTouch.UIKit.UITableViewSource" /> (or <see cref="T:MonoTouch.UIKit.UITableView.DataSource" />) can selectively exclude cells from editing mode by returning <see langword="false" /> from <see cref="M:MonoTouch.UIKit.UITableViewSource.CanEditRow(MonoTouch.UIKit.UITableView,MonoTouch.Foundation.NSIndexPath)" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UITableViewSource Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewSource Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A MonoTouch-specific feature that uses a <see cref="T:MonoTouch.UIKit.UITableViewSource" /> subclass to act as both <see cref="P:MonoTouch.UIKit.UITableView.Delegate" /> or <see cref="P:MonoTouch.UIKit.UITableView.DataSource" />.</summary>
        <value>A class that can behave as both <see cref="P:MonoTouch.UIKit.UITableView.Delegate" /> and <see cref="P:MonoTouch.UIKit.UITableView.DataSource" /> for the table view.</value>
        <remarks>
          <para>MonoTouch provides the <see cref="T:MonoTouch.UIKit.UITableViewSource" /> class as an alternative to implementing both <see cref="T:MonoTouch.UIKit.UITableViewDataSource" /> and <see cref="T:MonoTouch.UIKit.UITableViewDelegate" />. If a subclass of <see cref="T:MonoTouch.UIKit.UITableViewSource" /> is created and assigned to this property, the <see cref="P:MonoTouch.UIKit.UITableView.DataSource" /> and <see cref="P:MonoTouch.UIKit.UITableView.Delegate" /> properties should not be set.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewStyle Style { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UITableViewStyle Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("style")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the style of the table view (read-only).</summary>
        <value>
        </value>
        <remarks>A table view's style is set in the constructor and cannot be changed.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableFooterView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView TableFooterView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView TableFooterView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tableFooterView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTableFooterView:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a view that is displayed below the table view.</summary>
        <value>The default value is <see langword="null" />.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>The table footer view is different to a section footer.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableHeaderView">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView TableHeaderView { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView TableHeaderView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("tableHeaderView", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setTableHeaderView:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a view that is displayed above the table view.</summary>
        <value>The default value is <see langword="null" />.<para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>The table header view is different from a section header.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibleCells">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UITableViewCell[] VisibleCells { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UITableViewCell[] VisibleCells" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("visibleCells")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UITableViewCell[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an array of <see cref="T:MonoTouch.UIKit.UITableViewCell" /> that are currently visible in the table view.</summary>
        <value>An array containing <see cref="T:MonoTouch.UIKit.UITableViewCell" /> corresponding to the visible rows in the table view.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDataSource">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject WeakDataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject WeakDataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("dataSource", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setDataSource:", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>
          <para>(More documentation for this node is coming)</para>
          <para tool="nullallowed">This value can be <see langword="null" />.</para>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("delegate", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setDelegate:", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value><para>The instance that will respond to events and data requests.</para><para tool="nullallowed">This value can be <see langword="null" />.</para></value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
