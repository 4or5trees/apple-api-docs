<Type Name="UIPopoverController" FullName="MonoTouch.UIKit.UIPopoverController">
  <TypeSignature Language="C#" Value="public class UIPopoverController : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UIPopoverController extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo>
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("UIPopoverController", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Manages a popover on the screen.</summary>
    <remarks><para>The <tt>UIPopoverController</tt> class is used to manage the presentation of content in a popover. You use popovers to present information temporarily but in a way that does not take over the entire screen like a modal view does. The popover content is layered on top of your existing content in a special type of window. The popover remains visible until the user taps outside of the popover window or you explicitly dismiss it. Popover controllers are for use exclusively on iPad devices. Attempting to create one on other devices results in an exception.</para>
    <para>To display a popover, create an instance of this class and present it using one of the appropriate methods. When initializing an instance of this class, you must provide the view controller that provides the content for the popover. Popovers normally derive their size from the view controller they present. However, you can change the size of the popover by modifying the value in the <tt>popoverContentSize</tt> property or by calling the <tt>setPopoverContentSize:animated:</tt> method. The latter approach is particularly effective if you need to animate changes to the popover’s size. The size you specify is just the preferred size for the popover’s view. The actual size may be altered to ensure that the popover fits on the screen and does not collide with the keyboard.</para>
    <para>When displayed, taps outside of the popover window cause the popover to be dismissed automatically. To allow the user to interact with the specified views and not dismiss the popover, you can assign one or more views to the <tt>passthroughViews</tt> property. Taps inside the popover window do not automatically cause the popover to be dismissed. Your view and view controller code must handle actions and events inside the popover explicitly and call the <tt>dismissPopoverAnimated:</tt> method as needed.</para>
    <para>If the user rotates the device while a popover is visible, the popover controller hides the popover and then shows it again at the end of the rotation. The popover controller attempts to position the popover appropriately for you but you may have to present it again or hide it altogether in some cases. For example, when displayed from a bar button item, the popover controller automatically adjusts the position (and potentially the size) of the popover to account for changes to the position of the bar button item. However, if you remove the bar button item during the rotation, or if you presented the popover from a target rectangle in a view, the popover controller does not attempt to reposition the popover. In those cases, you must manually hide the popover or present it again from an appropriate new position. You can do this in the <tt>didRotateFromInterfaceOrientation:</tt> method of the view controller that you used to present the popover.</para>
    <para>You can assign a delegate to the popover to manage interactions with the popover and receive notifications about its dismissal.</para>
    </remarks>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=08f52114-da41-447b-92a4-b86981b03c21">Popovers</related>
    <related type="sample" href="http://samples.xamarin.com/Samples/ByGuid?guid=afab3ce5-a98f-43d8-a981-c803ca8b9738">Example_CoreAnimation</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIPopoverController (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">The unarchiver object.</param>
        <summary>A constructor that initializes the object from the data stored in the unarchiver object.</summary>
        <remarks>This constructor is provided to allow the class to be initialized from an unarchiver (for example, during NIB deserialization).</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIPopoverController (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">Unused sentinel value, pass NSObjectFlag.Empty.</param>
        <summary>Constructor to call on derived classes to skip initialization and merely allocate the object.</summary>
        <remarks>
          <para>This constructor should be called by derived classes when they completely construct the object in managed code and merely want the runtime to allocate and initialize the NSObject.   This is required to implement the two-step initialization process that Objective-C uses, the first step is to perform the object allocation, the second step is to initialize the object.   When you invoke the constructor that takes the NSObjectFlag.Empty you taking advatnage of a direct path that goes all the way up to NSObject to merely allocate the object's memory and bind the Objective-C and C# objects together.    The actual initialization of the object is up to you.</para>
          <para>This constructor is typically used by the binding generator to allocate the object, but prevent the actual initialization to take place.   Once the allocation has taken place, the constructor has to initialize the object.   With constructors generated by the binding generator this means that it manually invokes one of the "init" methods to initialize the object.</para>
          <para>It is your responsability to completely initialize the object if you chain up using the NSObjectFlag.Empty path.</para>
          <para>In general, if your constructors invokes the NSObjectFlag.Empty base implementation, then it should be calling an Objective-C init method.   If this is not the case, you should instead chain to the proper constructor in your class. </para>
          <para>The argument value is ignored and merely ensures that the only code that is executed is the construction phase is the basic NSObject allocation and runtime type registration.  Typically the chaining would look like this:</para>
          <example>
            <code lang="C#">
//
// The NSObjectFlag merely allocates the object and registers the
// C# class with the Objective-C runtime if necessary, but no actual
// initXxx method is invoked, that is done later in the constructor
//
// This is taken from MonoTouch's source code:
//
[Export ("initWithFrame:")]
public UIView (System.Drawing.RectangleF frame) : base (NSObjectFlag.Empty)
{
// Invoke the init method now.
	var initWithFrame = new Selector ("initWithFrame:").Handle;
	if (IsDirectBinding)
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSend_RectangleF (this.Handle, initWithFrame, frame);
	else
		Handle = MonoTouch.ObjCRuntime.Messaging.IntPtr_objc_msgSendSuper_RectangleF (this.SuperHandle, initWithFrame, frame);
}
</code>
          </example>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIPopoverController (MonoTouch.UIKit.UIViewController viewController);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.UIKit.UIViewController viewController) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithContentViewController:")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="viewController" Type="MonoTouch.UIKit.UIViewController" />
      </Parameters>
      <Docs>
        <param name="viewController">The view controller for managing the popover’s content. This parameter must not be <tt>null</tt>.</param>
        <summary>To be added.</summary>
        <remarks>When initializing a popover controller, you must specify the view controller object whose content is to be displayed in the popover. You can change this view controller later by modifying the <tt>contentViewController</tt> property.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIPopoverController (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Pointer (handle) to the unmanaged object.</param>
        <summary>A constructor used when creating managed representations of unmanaged objects;  Called by the runtime.</summary>
        <remarks>
          <para>This constructor is invoked by the runtime infrastructure (<see cref="M:MonoTouch.ObjCRuntime.GetNSObject (System.IntPtr)" />) to create a new managed representation for a pointer to an unmanaged Objective-C object.    You should not invoke this method directly, instead you should call the GetNSObject method as it will prevent two instances of a managed object to point to the same native object.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The handle for this class.</summary>
        <value>The pointer to the Objective-C class.</value>
        <remarks>Each MonoTouch class mirrors an unmanaged Objective-C class.   This value contains the pointer to the Objective-C class, it is similar to calling objc_getClass with the object name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentViewController">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIViewController ContentViewController { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIViewController ContentViewController" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("contentViewController", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setContentViewController:", MonoTouch.ObjCRuntime.ArgumentSemantic.Retain)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIViewController</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The view controller responsible for the content portion of the popover.</summary>
        <value>To be added.</value>
        <remarks>This property is initially set to the view controller passed to the <tt>initWithContentViewController:</tt> method. You can change the value of this property later to reflect a new set of content. Changing the value of this property swaps the new view controller in for the old one immediately and does not trigger an animation. If you want to animate the change, use the <tt>setContentViewController:animated:</tt> method instead.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UIPopoverControllerDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIPopoverControllerDelegate Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIPopoverControllerDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An instance of the MonoTouch.UIKit.UIPopoverControllerDelegate model class which acts as the class delegate.</summary>
        <value>The instance of the MonoTouch.UIKit.UIPopoverControllerDelegate model class</value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>This is the strongly typed version of the object, use the WeakDelegate property instead if you want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DidDismiss">
      <MemberSignature Language="C#" Value="public event EventHandler DidDismiss;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DidDismiss" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Event raised by the object.</summary>
        <remarks>If you assign a value to this event, this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dismiss">
      <MemberSignature Language="C#" Value="public virtual void Dismiss (bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dismiss(bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("dismissPopoverAnimated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="animated">Specify <tt>true</tt> to animate the dismissal of the popover or <tt>false</tt> to dismiss it immediately.</param>
        <summary>Dismisses the popover programmatically.</summary>
        <remarks>You can use this method to dismiss the popover programmatically in response to taps inside the popover window. Taps outside of the popover’s contents automatically dismiss the popover.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resourced used by the UIPopoverController object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the UIPopoverController class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposting <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the UIPopoverController ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PassthroughViews">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIView[] PassthroughViews { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIView[] PassthroughViews" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("passthroughViews", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setPassthroughViews:", MonoTouch.ObjCRuntime.ArgumentSemantic.Copy)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIView[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An array of views that the user can interact with while the popover is visible.</summary>
        <value>To be added.</value>
        <remarks>When a popover is active, interactions with other views are normally disabled until the popover is dismissed. Assigning an array of views to this property allows taps outside of the popover to be handled by the corresponding views.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopoverArrowDirection">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIPopoverArrowDirection PopoverArrowDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIPopoverArrowDirection PopoverArrowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("popoverArrowDirection")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIPopoverArrowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopoverBackgroundViewType">
      <MemberSignature Language="C#" Value="public virtual Type PopoverBackgroundViewType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PopoverBackgroundViewType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.ObjCRuntime.Since(5, 0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The direction of the popover’s arrow. (read-only)</summary>
        <value>To be added.</value>
        <remarks>The default value of this property is <tt>UIPopoverArrowDirectionUnknown</tt>. When you present the popover, the value changes to reflect the actual direction of the arrow being used by the popover. When the popover is subsequently dismissed, the value of this property returns to <tt>UIPopoverArrowDirectionUnknown</tt>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopoverContentSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.SizeF PopoverContentSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.SizeF PopoverContentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("popoverContentSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setPopoverContentSize:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The size of the popover’s content view.</summary>
        <value>To be added.</value>
        <remarks><para>This property represents the size of the content view that is managed by the view controller in the <tt>contentViewController</tt> property. The initial value of this property is set to value in the view controller’s <tt>contentSizeForViewInPopover</tt> property. Changing the value of this property overrides the default value of the current view controller. The overridden value persists until you assign a new content view controller to the receiver. Thus, if you want to keep your overridden value, you must reassign it after changing the content view controller.</para>
        <para>When changing the value of this property, the width value you specify must be at least 320 points and no more than 600 points. There are no restrictions on the height value. However, both the width and height values you specify may be adjusted to ensure the popup fits on screen and is not covered by the keyboard. If you change the value of this property while the popover is visible, the size change is animated.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PopoverLayoutMargins">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.UIKit.UIEdgeInsets PopoverLayoutMargins { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype MonoTouch.UIKit.UIEdgeInsets PopoverLayoutMargins" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("popoverLayoutMargins")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setPopoverLayoutMargins:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIEdgeInsets</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The margins that define the portion of the screen in which it is permissible to display the popover.</summary>
        <value>To be added.</value>
        <remarks><para>The edge inset values are measured in points from the edges of the screen, relative to the current device orientation. Thus, the top-edge inset always reflects the top edge of the device from the user’s perspective, which changes depending on whether the user is holding the device in a portrait or landscape orientation. Remember that the device orientation is not always the same as the interface orientation—that is, the orientation of your window and views. Window orientations are typically fixed and view orientations are controlled by the owning view controller. In addition, if the rotation lock option is engaged, the interface does not change orientation at all, even when the device orientation changes.</para>
        <para>The default edge insets are 10 points along each edge. The popover controller automatically subtracts the status bar from the viable area when determining where to display the popover, so you do not need to factor the status bar height into your insets.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PopoverVisible">
      <MemberSignature Language="C#" Value="public virtual bool PopoverVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PopoverVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isPopoverVisible")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A Boolean value indicating whether the popover is currently visible. (read-only)</summary>
        <value>To be added.</value>
        <remarks>You must present the popover to make it visible.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentFromBarButtonItem">
      <MemberSignature Language="C#" Value="public virtual void PresentFromBarButtonItem (MonoTouch.UIKit.UIBarButtonItem item, MonoTouch.UIKit.UIPopoverArrowDirection arrowDirections, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PresentFromBarButtonItem(class MonoTouch.UIKit.UIBarButtonItem item, valuetype MonoTouch.UIKit.UIPopoverArrowDirection arrowDirections, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("presentPopoverFromBarButtonItem:permittedArrowDirections:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="MonoTouch.UIKit.UIBarButtonItem" />
        <Parameter Name="arrowDirections" Type="MonoTouch.UIKit.UIPopoverArrowDirection" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="item">The bar button item on which to anchor the popover.</param>
        <param name="arrowDirections">The arrow directions the popover is permitted to use. You can use this value to force the popover to be positioned on a specific side of the bar button item. However, it is generally better to specify <tt>UIPopoverArrowDirectionAny</tt> and let the popover decide the best placement. You must not specify <tt>UIPopoverArrowDirectionUnknown</tt> for this parameter.</param>
        <param name="animated">Specify <tt>true</tt> to animate the presentation of the popover or <tt>false</tt> to display it immediately.</param>
        <summary>Displays the popover and anchors it to the specified bar button item.</summary>
        <remarks>When presenting the popover, this method adds the toolbar that owns the button to the popover’s list of passthrough views. Thus, taps in the toolbar result in the action methods of the corresponding toolbar items being called. If you want the popover to be dismissed when a different toolbar item is tapped, you must implement that behavior in your action handler methods.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PresentFromRect">
      <MemberSignature Language="C#" Value="public virtual void PresentFromRect (System.Drawing.RectangleF rect, MonoTouch.UIKit.UIView view, MonoTouch.UIKit.UIPopoverArrowDirection arrowDirections, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PresentFromRect(valuetype System.Drawing.RectangleF rect, class MonoTouch.UIKit.UIView view, valuetype MonoTouch.UIKit.UIPopoverArrowDirection arrowDirections, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("presentPopoverFromRect:inView:permittedArrowDirections:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="view" Type="MonoTouch.UIKit.UIView" />
        <Parameter Name="arrowDirections" Type="MonoTouch.UIKit.UIPopoverArrowDirection" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rect">The rectangle in view at which to anchor the popover window.</param>
        <param name="view">The view containing the anchor rectangle for the popover.</param>
        <param name="arrowDirections">The arrow directions the popover is permitted to use. You can use this value to force the popover to be positioned on a specific side of the rectangle. However, it is generally better to specify <tt>UIPopoverArrowDirectionAny</tt> and let the popover decide the best placement. You must not specify <tt>UIPopoverArrowDirectionUnknown</tt> for this parameter.</param>
        <param name="animated">Specify <tt>true</tt> to animate the presentation of the popover or <tt>false</tt> to display it immediately.</param>
        <summary>Displays the popover and anchors it to the specified location in the view.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetContentViewController">
      <MemberSignature Language="C#" Value="public virtual void SetContentViewController (MonoTouch.UIKit.UIViewController viewController, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetContentViewController(class MonoTouch.UIKit.UIViewController viewController, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setContentViewController:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewController" Type="MonoTouch.UIKit.UIViewController" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="viewController">The new view controller whose content should be displayed by the popover.</param>
        <param name="animated">Specify <tt>true</tt> if the change of view controllers should be animated or <tt>false</tt> if the change should occur immediately.</param>
        <summary>Sets the view controller responsible for the content portion of the popover.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPopoverContentSize">
      <MemberSignature Language="C#" Value="public virtual void SetPopoverContentSize (System.Drawing.SizeF size, bool animated);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetPopoverContentSize(valuetype System.Drawing.SizeF size, bool animated) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setPopoverContentSize:animated:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.SizeF" />
        <Parameter Name="animated" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="size">The new size to apply to the content view.</param>
        <param name="animated">Specify <tt>true</tt> if you want the change in size to be animated or <tt>false</tt> if you want the change to appear immediately.</param>
        <summary>Changes the size of the popover’s content view.</summary>
        <remarks>When changing the size of the popover’s content, the width value you specify must be at least 320 points and no more than 600 points. There are no restrictions on the height value. However, both the width and height values you specify may be adjusted to ensure the popup fits on screen and is not covered by the keyboard.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldDismiss">
      <MemberSignature Language="C#" Value="public MonoTouch.UIKit.UIPopoverControllerCondition ShouldDismiss { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.UIKit.UIPopoverControllerCondition ShouldDismiss" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.UIKit.UIPopoverControllerCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Delegate invoked by the object to get a value.</summary>
        <value>To be added.</value>
        <remarks>You assign a function, delegate or anonymous method to this property to return a value to the object.   If you assign a value to this property, it this will reset the value for the WeakDelegate property to an internal handler that maps delegates to events.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("delegate", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setDelegate:", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>An object that can respond to the delegate protocol for this type</summary>
        <value>The instance that will respond to events and data requests.</value>
        <remarks>
          <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
          <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
          <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
