<Type Name="CFMessagePort" FullName="MonoTouch.CoreFoundation.CFMessagePort">
  <TypeSignature Language="C#" Value="public class CFMessagePort : IDisposable, MonoTouch.ObjCRuntime.INativeObject" />
<<<<<<< HEAD
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CFMessagePort implements class MonoTouch.ObjCRuntime.INativeObject, class System.IDisposable" />
=======
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CFMessagePort extends System.Object implements class MonoTouch.ObjCRuntime.INativeObject, class System.IDisposable" />
>>>>>>> master
  <AssemblyInfo apistyle="classic">
    <AssemblyName>monotouch</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo apistyle="unified">
    <AssemblyName>Xamarin.iOS</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
<<<<<<< HEAD
=======
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
>>>>>>> master
  <Interfaces>
    <Interface>
      <InterfaceName>MonoTouch.ObjCRuntime.INativeObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
<<<<<<< HEAD
    <summary>This enumeration contains message codes for <see cref="M:MonoTouch.CoreFoundation.CFMessagePort.SendRequest" /></summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberType>Property</MemberType>
=======
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Check">
      <MemberSignature Language="C#" Value="protected void Check ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Check() cil managed" />
      <MemberType>Method</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Handle (pointer) to the unmanaged object representation.</summary>
        <value>A pointer.</value>
        <remarks>This IntPtr is a handle to the underlying unmanaged representation for this object.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRemote">
      <MemberSignature Language="C#" Value="public bool IsRemote { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRemote" />
=======
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public MonoTouch.CoreFoundation.CFMessagePortContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.CoreFoundation.CFMessagePortContext Context" />
>>>>>>> master
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a Boolean value that indicates whether a current instance of CFMessagePort object represents a remote port.</summary>
        <value>Boolean value.</value>
        <remarks>Property returns true if CFMessagePort is remote.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
=======
        <ReturnType>MonoTouch.CoreFoundation.CFMessagePortContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLocalPort">
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreFoundation.CFMessagePort CreateLocalPort (MonoTouch.CoreFoundation.CFAllocator allocator, string name, MonoTouch.CoreFoundation.CFMessagePort.CFMessagePortCallBack callback, MonoTouch.CoreFoundation.CFMessagePortContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.CoreFoundation.CFMessagePort CreateLocalPort(class MonoTouch.CoreFoundation.CFAllocator allocator, string name, class MonoTouch.CoreFoundation.CFMessagePort/CFMessagePortCallBack callback, class MonoTouch.CoreFoundation.CFMessagePortContext context) cil managed" />
      <MemberType>Method</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The registered name of message port.</summary>
        <value>String representation of message port's name.</value>
        <remarks> Property returns null if port have no name.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native bool IsValid" />
      <MemberType>Property</MemberType>
=======
        <ReturnType>MonoTouch.CoreFoundation.CFMessagePort</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allocator" Type="MonoTouch.CoreFoundation.CFAllocator" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="callback" Type="MonoTouch.CoreFoundation.CFMessagePort+CFMessagePortCallBack" />
        <Parameter Name="context" Type="MonoTouch.CoreFoundation.CFMessagePortContext" />
      </Parameters>
      <Docs>
        <param name="allocator">To be added.</param>
        <param name="name">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRemotePort">
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreFoundation.CFMessagePort CreateRemotePort (MonoTouch.CoreFoundation.CFAllocator allocator, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class MonoTouch.CoreFoundation.CFMessagePort CreateRemotePort(class MonoTouch.CoreFoundation.CFAllocator allocator, string name) cil managed" />
      <MemberType>Method</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a boolean value that indicates whether a CFMessagePort object is valid.</summary>
        <value>Boolean value.</value>
        <remarks>Property indicates whether message port can send or receive messages.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public MonoTouch.CoreFoundation.CFMessagePortContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class CoreFoundation.CFMessagePortContext Context" />
      <MemberType>Property</MemberType>
=======
        <ReturnType>MonoTouch.CoreFoundation.CFMessagePort</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allocator" Type="MonoTouch.CoreFoundation.CFAllocator" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="allocator">To be added.</param>
        <param name="name">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRunLoopSource">
      <MemberSignature Language="C#" Value="public MonoTouch.CoreFoundation.CFRunLoopSource CreateRunLoopSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class MonoTouch.CoreFoundation.CFRunLoopSource CreateRunLoopSource() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>MonoTouch.CoreFoundation.CFRunLoopSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberType>Method</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>MonoTouch.CoreFoundation.CFMessagePortContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the context information for a CFMessagePort object.</summary>
        <value>CFMessagePortContext structure.</value>
        <remarks>The context information being returned is usually the same information you passed to CFMessagePort.CreateLocal method when creating message port.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidationCallback">
      <MemberSignature Language="C#" Value="public System.Action InvalidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native System.Action InvalidationCallback" />
      <MemberType>Property</MemberType>
=======
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources used by the CFMessagePort object.</summary>
        <remarks>
          <para>The Dispose method releases the resources used by the CFMessagePort class.</para>
          <para>Calling the Dispose method when you are finished using the CFMessagePort ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.  For more information on releasing resources see ``Cleaning up Unmananaged Resources'' at http://msdn.microsoft.com/en-us/library/498928w2.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>System.Action</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets o sets the invalidation callback method for a CFMessagePort object.</summary>
        <value>Delegate</value>
        <remarks>Set null value to remove callback. Callback will be fired on message on port invalidation.</remarks>
=======
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <para>If set to <see langword="true" />, the method is invoked directly and will dispose manage and unmanaged resources;   If set to <see langword="false" /> the method is being called by the garbage collector finalizer and should only release unmanaged resources.</para>
        </param>
        <summary>Releases the resources used by the CFMessagePort object.</summary>
        <remarks>
          <para>This Dispose method releases the resources used by the CFMessagePort class.</para>
          <para>This method is called by both the Dispose() method and the object finalizer (Finalize).    When invoked by the Dispose method, the parameter disposing <paramref name="disposing" /> is set to <see langword="true" /> and any managed object references that this object holds are also disposed or released;  when invoked by the object finalizer, on the finalizer thread the value is set to <see langword="false" />. </para>
          <para>Calling the Dispose method when you are finished using the CFMessagePort ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.</para>
          <para>  For more information on how to override this method and on the Dispose/IDisposable pattern, read the ``Implementing a Dispose Method'' document at http://msdn.microsoft.com/en-us/library/fs2xkftw.aspx</para>
        </remarks>
>>>>>>> master
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CFMessagePort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finalizer for the CFMessagePort object</summary>
        <remarks>
        </remarks>
      </Docs>
    </Member>
<<<<<<< HEAD
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
=======
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Handle (pointer) to the unmanaged object representation.</summary>
        <value>A pointer</value>
        <remarks>This IntPtr is a handle to the underlying unmanaged representation for this object.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
>>>>>>> master
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
<<<<<<< HEAD
        <summary>Releases the resources used by the CFMessagePort object.</summary>
        <remarks>
          <para>The Dispose method releases the resources used by the CFMessagePort class.</para>
          <para>Calling the Dispose method when you are finished using the CFMessagePort ensures that all external resources used by this managed object are released as soon as possible.  Once you have invoked the Dispose method, the object is no longer useful and you should no longer make any calls to it.  For more information on releasing resources see ``Cleaning up Unmananaged Resources'' at http://msdn.microsoft.com/en-us/library/498928w2.aspx</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateLocalPort">
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreFoundation.CFMessagePort CreateLocalPort (MonoTouch.CoreFoundation.CFAllocator allocator, string name, MonoTouch.CoreFoundation.CFMessagePort.CFMessagePortCallBack callback, MonoTouch.CoreFoundation.CFMessagePortContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig static class CoreFoundation.CFMessagePort CreateLocalPort (class [Xamarin.iOS]CoreFoundation.CFAllocator allocator,string name, class CoreFoundation.CFMessagePort/CFMessagePortCallBack callback, class CoreFoundation.CFMessagePortContext context) cil managed" />
      <MemberType>Method</MemberType>
=======
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidationCallback">
      <MemberSignature Language="C#" Value="public Action InvalidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action InvalidationCallback" />
      <MemberType>Property</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>MonoTouch.CoreFoundation.CFMessagePort</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allocator" Type="MonoTouch.CoreFoundation.CFAllocator" />
        <Parameter Name="name" Type="string" />
        <Parameter Name="callback" Type="MonoTouch.CoreFoundation.CFMessagePort.CFMessagePortCallBack" />
        <Parameter Name="context" Type="MonoTouch.CoreFoundation.CFMessagePortContext" />
      </Parameters>
      <Docs>
        <param name="allocator">The allocator to use to allocate memory for the new object. Pass null or CFAllocator.Default to use the current default allocator.</param>
        <param name="name">The name with which to register the port, can be null or empty string.</param>
        <param name="callback">The callback function invoked when a message is received on the message port.</param>
        <param name="context">A structure holding contextual information for the message port.</param>
        <summary>
          <para>Method creates new CFMessagePort object or returns null on failure.</para>
          <para>
          </para>
          <example>
            <code lang="C#"><![CDATA[var messagePort = CFMessagePort.CreateLocalPort (CFAllocator.Default, "com.watch.CFMessagePort.server", new CFMessagePort.CFMessagePortCallBack (MessageHandler), null);]]></code>
          </example>
        </summary>
        <returns>CFMessagePort instance</returns>
        <remarks>If a local port is already exists, the function returns that port instead of creating a new message port.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRemotePort">
      <MemberSignature Language="C#" Value="public static MonoTouch.CoreFoundation.CFMessagePort CreateRemotePort (MonoTouch.CoreFoundation.CFAllocator allocator, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig static class CoreFoundation.CFMessagePort CreateRemotePort (class [Xamarin.iOS]CoreFoundation.CFAllocator allocator,string name) cil managed" />
      <MemberType>Method</MemberType>
=======
        <ReturnType>System.Action</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRemote">
      <MemberSignature Language="C#" Value="public bool IsRemote { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRemote" />
      <MemberType>Property</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>MonoTouch.CoreFoundation.CFMessagePort</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allocator" Type="MonoTouch.CoreFoundation.CFAllocator" />
        <Parameter Name="name" Type="string" />
      </Parameters>
      <Docs>
        <param name="allocator">The allocator to use to allocate memory for the new object. Pass null or CFAllocator.Default to use the current default allocator.</param>
        <param name="name">The name of the remote message port to which to connect.</param>
        <summary>
          <para>The new CFMessagePort object, or null on failure. If a message port has already been created for the remote port, the pre-existing object is returned.</para>
          <para>
          </para>
          <example>
            <code lang="C#"><![CDATA[var messagePort = CFMessagePort.CreateRemotePort (CFAllocator.Default, "com.watch.CFMessagePort.server");]]></code>
          </example>
        </summary>
        <returns>CFMessagePort instance</returns>
        <remarks>Returns a CFMessagePort object connected to a remote port.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate () cil managed" />
      <MemberType>Method</MemberType>
=======
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberType>Property</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invalidating a message port prevents the port from ever sending or receiving any more messages. </summary>
        <returns>void</returns>
        <remarks>The message port is not deallocated after invalidation, however <see cref="P:MonoTouch.CoreFoundation.CFMessagePort.IsValid" /> property is set to be true.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendRequest">
      <MemberSignature Language="C#" Value="public MonoTouch.CoreFoundation.SendRequest SendRequest (int msgid, MonoTouch.Foundation.NSData data, double sendTimeout, double rcvTimeout, MonoTouch.Foundation.NSString replyMode, out MonoTouch.Foundation.NSData returnData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype CoreFoundation.SendRequestResult SendRequest (int32 msgid, class MonoTouch.Foundation.NSData data, float64 sendTimeout, float64 rcvTimeout, class MonoTouchFoundation.NSString replyMode, [out] class MonoTouch.Foundation.NSData&gt; returnData) cil managed" />
      <MemberType>Method</MemberType>
=======
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberType>Property</MemberType>
>>>>>>> master
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>MonoTouch.CoreFoundation.SendRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msgid" Type="int32" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="sendTimeout" Type="float64" />
        <Parameter Name="rcvTimeout" Type="float64" />
        <Parameter Name="replyMode" Type="MonoTouchFoundation.NSString" />
        <Parameter Name="returnData" Type="MonoTouch.Foundation.NSData" />
      </Parameters>
      <Docs>
        <param name="msgid">An arbitrary integer value that you can send with the message.</param>
        <param name="data">The data to send to remote port.</param>
        <param name="sendTimeout">The time to wait for data to be sent.</param>
        <param name="rcvTimeout">The time to wait for a reply to be returned.</param>
        <param name="replyMode">The run loop mode in which the function should wait for a reply.</param>
        <param name="returnData">Upon return, contains a NSData object containing the reply data.</param>
        <summary>
          <para>Sends a message to a remote CFMessagePort object.</para>
          <para>
          </para>
          <example>
            <code lang="C#"><![CDATA[var result = messagePort.SendRequest (4369, NSData.FromString (GetColorComponents (color)), 10.0, 10.0, CFRunLoop.ModeDefault, out replyData);]]></code>
          </example>
        </summary>
        <returns>NSData reply from remote port</returns>
        <remarks> Set replyMode to null if message is one-way. If replyMode is non null, the function runs the loop waiting for a reply, in selected.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRunLoopSource">
      <MemberSignature Language="C#" Value="public MonoTouch.CoreFoundation.CFRunLoopSource CreateRunLoopSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig      instance class MonoTouch.CoreFoundation.CFRunLoopSource CreateRunLoopSource () cil managed" />
=======
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SendRequest">
      <MemberSignature Language="C#" Value="public MonoTouch.CoreFoundation.CFMessagePortSendRequestStatus SendRequest (int msgid, MonoTouch.Foundation.NSData data, double sendTimeout, double rcvTimeout, MonoTouch.Foundation.NSString replyMode, out MonoTouch.Foundation.NSData returnData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype MonoTouch.CoreFoundation.CFMessagePortSendRequestStatus SendRequest(int32 msgid, class MonoTouch.Foundation.NSData data, float64 sendTimeout, float64 rcvTimeout, class MonoTouch.Foundation.NSString replyMode, class MonoTouch.Foundation.NSData returnData) cil managed" />
>>>>>>> master
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
<<<<<<< HEAD
        <ReturnType>MonoTouch.CoreFoundation.CFRunLoopSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a CFRunLoopSource object for a CFMessagePort object.</summary>
        <returns>The new CFRunLoopSource object for listening port</returns>
        <remarks>Method returns loop which is not added to any run loop. Use <see cref="M:MonoTouch.CoreFoundation.CFRunLoop.AddSource" /> to activate the loop.</remarks>
=======
        <ReturnType>MonoTouch.CoreFoundation.CFMessagePortSendRequestStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msgid" Type="System.Int32" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="sendTimeout" Type="System.Double" />
        <Parameter Name="rcvTimeout" Type="System.Double" />
        <Parameter Name="replyMode" Type="MonoTouch.Foundation.NSString" />
        <Parameter Name="returnData" Type="MonoTouch.Foundation.NSData&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="msgid">To be added.</param>
        <param name="data">To be added.</param>
        <param name="sendTimeout">To be added.</param>
        <param name="rcvTimeout">To be added.</param>
        <param name="replyMode">To be added.</param>
        <param name="returnData">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
>>>>>>> master
      </Docs>
    </Member>
    <Member MemberName="SetDispatchQueue">
      <MemberSignature Language="C#" Value="public void SetDispatchQueue (MonoTouch.CoreFoundation.DispatchQueue queue);" />
<<<<<<< HEAD
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDispatchQueue (class [Xamarin.iOS]CoreFoundation.DispatchQueue queue) cil managed" />
=======
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDispatchQueue(class MonoTouch.CoreFoundation.DispatchQueue queue) cil managed" />
>>>>>>> master
      <MemberType>Method</MemberType>
      <AssemblyInfo apistyle="classic">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo apistyle="unified">
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
<<<<<<< HEAD
      <Parameters />
      <Docs>
        <summary>Schedules message port’s callbacks on the specified dispatch queue.</summary>
        <returns>void</returns>
=======
      <Parameters>
        <Parameter Name="queue" Type="MonoTouch.CoreFoundation.DispatchQueue" />
      </Parameters>
      <Docs>
        <param name="queue">To be added.</param>
        <summary>To be added.</summary>
>>>>>>> master
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
